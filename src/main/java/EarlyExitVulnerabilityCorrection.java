import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtLocalVariableReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.ReturnOrThrowFilter;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import spoon.support.reflect.declaration.CtMethodImpl;
import util.NamingConvention;
import java.util.*;
import java.util.stream.Stream;

public class EarlyExitVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(EarlyExitVulnerabilityCorrection.class);
    private static CtElement cycleElement = null;
    private static final ArrayList<String> variablesNullChecked = new ArrayList<>();

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod) {
        NamingConvention.resetCounter();
        List<CtCFlowBreak> returnList = modifiedMethod.getElements(new ReturnOrThrowFilter());
        returnList.removeIf(returnOrThrow -> !(returnOrThrow instanceof CtReturnImpl));

        int numberOfReturns = returnList.size();
        if (numberOfReturns <= 1) {
            return;
        }

        logger.info("The method suffers from early-exit timing side-channel vulnerability since it has {} exit points.",
                numberOfReturns);

        List<CtLocalVariable<?>> variableList = modifiedMethod.getElements(new TypeFilter<>(CtLocalVariable.class));
        CtBlock<?> modifiedMethodBody = modifiedMethod.getBody();

        int lastIndex = numberOfReturns - 1;
        CtReturnImpl<?> finalReturnElement = (CtReturnImpl<?>) returnList.get(lastIndex);
        CtExpression<?> returnedExpression = finalReturnElement.getReturnedExpression();

        Optional<CtLocalVariable<?>> optionalReturnAssignment = variableList.stream()
                .filter(it -> it.getReference().toString().matches(".*\\b" + returnedExpression + "\\b.*"))
                .findFirst();

        CtExpression<?> returnElement = findValueToReturn(variableList, returnedExpression, returnedExpression);

        CtLocalVariable variable = createReturnVariable(factory, modifiedMethod.getType(), variableList, modifiedMethodBody,
                optionalReturnAssignment, returnElement);

        boolean afterCycleReturn = false;
        Iterator<CtCFlowBreak> returnsIterator = returnList.iterator();

        while (returnsIterator.hasNext()) {
            CtReturnImpl<?> returnImpl = (CtReturnImpl<?>) returnsIterator.next();
            CtElement parentElement = returnImpl.getParent().getParent();
            if (afterCycleReturn && !(parentElement instanceof CtMethodImpl)) {
                modifyCodeAfterReturnInCycle(factory, returnImpl);
                returnImpl.delete();
            }
            if (!(parentElement instanceof CtMethodImpl) && isInsideCycle(returnImpl)) {    // If the return is inside a cycle
                afterCycleReturn = true;
            }
            if (parentElement instanceof CtIfImpl) {
                modifyIfCondition(factory, (CtIfImpl) parentElement);
            }
            if (!returnsIterator.hasNext()) {
                modifyLastReturn(factory, modifiedMethodBody, returnElement, variable, returnImpl);
                break;
            }

            CtExpression<?> returnedValue = returnImpl.getReturnedExpression();
            CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(variable.getReference(), false, returnedValue);
            variableAssignment.setType(variable.getType());
            returnImpl.replace(variableAssignment);
        }

        if (!variablesNullChecked.isEmpty()) {
            protectVariableAccess(factory, variableList);
        }
    }

    /**
     * Determines if the final return, returns the result of a method invocation. If so, it is important to ensure that
     * all arguments passed to the method are available at the start of the method execution. Otherwise the created variable
     * will be declared without a starting value.
     * @param variableList the list of variables in the method.
     * @param returnedExpression the expression returned in the last return of the method.
     * @param finalReturn   The value returned in the last return of the method.
     * @return The value to initiate the new variable with.
     */
    private static CtExpression<?> findValueToReturn(List<CtLocalVariable<?>> variableList, CtExpression<?> returnedExpression, CtExpression<?> finalReturn) {
        CtExpression<?> returnElement;
        if (returnedExpression instanceof CtInvocation) {
            Stream<?> lastReturnInvocationArguments = ((CtInvocationImpl<?>) returnedExpression)
                    .getArguments()
                    .stream()
                    .flatMap(elem -> Arrays.stream(elem.toString().split("\\.")).limit(1));

            if (lastReturnInvocationArguments.noneMatch(argument -> variableList.stream().anyMatch(variable -> variable.getReference().getDeclaration().getSimpleName().equals(argument)))) {
                returnElement = finalReturn;
            } else
                returnElement = null;
        } else if (returnedExpression instanceof CtBinaryOperator)
            returnElement = null;
        else
            returnElement = finalReturn;
        return returnElement;
    }

    /**
     * Method where the variable used to contain the value to be returned in the end of the method is created. Or the existing
     * variable to be return is added to the beginning of the method to allow assignment anywhere in the method where a return
     * exists.
     * @param factory The factory used to create code snippets to add.
     * @param methodReturnType The return type of the method to modify.
     * @param variableList  The list of variables created inside the method
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param optionalReturnAssignment  If a value is present it means that a new variable to be returned needs to be created.
     * @param returnElement The element to return.
     * @return The variable to be returned, either an existing variable or the newly created one.
     */
    private static CtLocalVariable<?> createReturnVariable(Factory factory, CtTypeReference<?> methodReturnType, List<CtLocalVariable<?>> variableList,
                                               CtBlock<?> modifiedMethodBody,
                                               Optional<CtLocalVariable<?>> optionalReturnAssignment,
                                               CtExpression<?> returnElement) {

        CtLocalVariable<?> newVariable = null;

        if (!optionalReturnAssignment.isPresent()) {
            newVariable = NamingConvention.produceNewVariable(factory, methodReturnType, returnElement);
            modifiedMethodBody.addStatement(0, newVariable);
            logger.info("Added the instruction {}.", newVariable);
        } else {
            CtLocalVariable<?> returnAssignmentToRemove = optionalReturnAssignment.get();
            CtLocalVariable<?> returnAssignmentToAdd = returnAssignmentToRemove.clone();

            if (returnAssignmentToRemove.getDefaultExpression() instanceof CtNewArrayImpl) {    // In response to themis_dynatable_unsafe
                List<CtExpression<Integer>> dimensionExpressions = ((CtNewArrayImpl<?>) returnAssignmentToRemove.getDefaultExpression())
                        .getDimensionExpressions();

                for (CtLocalVariable<?> variable : variableList) {
                    if (dimensionExpressions.stream().anyMatch(arraySize -> variable.getSimpleName().equals(arraySize.toString()))) {
                        String returnName = returnAssignmentToRemove.getSimpleName();
                        CtExpression assignment = returnAssignmentToRemove.getAssignment();
                        CtTypeReference<?> returnType = returnAssignmentToRemove.getType();

                        newVariable = factory.createLocalVariable(returnType, returnName, null);
                        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(newVariable.getReference(), false, assignment);
                        returnAssignmentToRemove.replace(variableAssignment);
                        modifiedMethodBody.addStatement(0, newVariable);
                        break;
                    }
                }
            } else {
                modifiedMethodBody.removeStatement(returnAssignmentToRemove);
                modifiedMethodBody.addStatement(0, returnAssignmentToAdd);
                newVariable = returnAssignmentToAdd;
            }
        }
        return newVariable;
    }

    /** TODO correct comment
     * The process to modify the code after a replacement of a return inside a cycle as occurred. Here it is important to
     * guarantee that the value assigned to the returned variable is not replaced, but also that if the returned variable
     * is not modified inside the cycle the correct value is returned
     * @param factory   The factory used to create code snippets to add.
     * @param returnImpl   The return expression to be replaced.
     */
    private static void modifyCodeAfterReturnInCycle(Factory factory, CtReturnImpl<?> returnImpl) {
        CtExpression afterCycleReturnedExpression = returnImpl.getReturnedExpression();
        CtLocalVariable<?> variable = NamingConvention.getLocalVariable();
        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(variable.getReference(), false, afterCycleReturnedExpression);
        ArrayList<CtElement> arrayList = new ArrayList<>();
        arrayList.add(variableAssignment);
        arrayList.add(cycleElement);
        cycleElement.replace(arrayList);    //  To avoid a semicolon after the cycle. As a response of test 26 of example github_authmereloaded.
    }

    /**
     * Checks if the current return instruction to be replaced occurs inside a cycle.
     * @param returnImpl    The return instruction to be replaced.
     * @return  true - if the return happens inside a cycle, false - otherwise.
     */
    private static boolean isInsideCycle(CtReturnImpl<?> returnImpl) {
        CtElement parent = returnImpl.getParent();
        while (!(parent instanceof CtMethodImpl)) {
            if (parent instanceof CtLoop) {
                cycleElement = parent;
                return true;
            }
            parent = parent.getParent();
        }
        return false;
    }

    /**
     * Modifies the condition of the if. This is important when accessing an array, to avoid IndexOutOfBoundsException.
     * Since it is likely that the condition to avoid the IndexOutOfBoundsException no longer work to avoid early-exit
     * timing side-channel.
     * @param factory   The factory used to create code snippets to add.
     * @param ifStatement   The if statement to be modified.
     */
    private static void modifyIfCondition(Factory factory, CtIfImpl ifStatement) {
        if (ifStatement.getCondition() instanceof CtBinaryOperator) {
            boolean modification = false;
            CtBinaryOperator<Boolean> condition = (CtBinaryOperator<Boolean>) ifStatement.getCondition();
            CtExpression<?> leftHandOperator = condition.getLeftHandOperand();
            CtExpression<?> rightHandOperator = condition.getRightHandOperand();
            CtBinaryOperator<Boolean> newLeftHand = null;
            CtBinaryOperator<Boolean> newRightHand = null;

            verifyNullCheck(leftHandOperator, rightHandOperator);

            if (leftHandOperator instanceof CtFieldReadImpl) {
                CtExpression<?> variable = ((CtFieldReadImpl<?>) leftHandOperator).getTarget();
                CtBinaryOperator<Boolean> result = addNullCheck(factory, variable);
                if (result != null) {
                    newLeftHand = result;
                    modification = true;
                }
            } else if (leftHandOperator instanceof CtArrayReadImpl) {
                newLeftHand = addLengthCheck(factory, (CtArrayReadImpl<?>) leftHandOperator);
                modification = true;
            }

            if (rightHandOperator instanceof CtFieldReadImpl) {
                CtExpression<?> variable = ((CtFieldReadImpl<?>) rightHandOperator).getTarget();
                CtBinaryOperator<Boolean> result = addNullCheck(factory, variable);
                if (result != null) {
                    newRightHand = result;
                    modification = true;
                }
            } else if (rightHandOperator instanceof CtArrayReadImpl) {
                newRightHand = addLengthCheck(factory, (CtArrayReadImpl<?>) rightHandOperator);
                modification = true;
            }

            if (modification) {
                CtBinaryOperator<Boolean> addedCondition;
                if (newLeftHand != null && newRightHand != null) {
                    addedCondition = factory.createBinaryOperator(newLeftHand, newRightHand, BinaryOperatorKind.AND);
                } else {
                    addedCondition = newLeftHand != null ? newLeftHand : newRightHand;
                }

                CtBinaryOperator<Boolean> newConditional = factory.createBinaryOperator(addedCondition, condition, BinaryOperatorKind.AND);
                ifStatement.setCondition(newConditional);
            }
        }
    }

    /**
     * Modifies the final return of the vulnerable method. This needs to be different because it will not only eliminate
     * a return expression but modified. If the last return was an expression and it wasn't already assigned to the return
     * variable it is now, and a new return expression is created.
     * @param factory   The factory used to create code snippets to add.
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param returnElement The element to return.
     * @param variable  The name of the variable to be returned.
     * @param returnImpl    The return instruction to be replaced.
     */
    private static void modifyLastReturn(Factory factory, CtBlock<?> modifiedMethodBody, CtExpression<?> returnElement, CtLocalVariable<?> variable,
                                         CtReturnImpl<?> returnImpl) {

        CtExpression<?> returnedValue = returnImpl.getReturnedExpression();
        CtReturn<?> objectCtReturn = factory.createReturn().setReturnedExpression(factory.createCodeSnippetExpression(variable.getSimpleName()));

        if (returnElement == null || !returnElement.toString().contains(returnedValue.toString())) {
            CtLocalVariableReference variableReference = variable.getReference();
            CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(variableReference, false, returnedValue);
            returnImpl.replace(variableAssignment);
            modifiedMethodBody.addStatement(objectCtReturn);
        } else {
            returnImpl.replace(objectCtReturn);
        }
    }

    private static void protectVariableAccess(Factory factory, List<CtLocalVariable<?>> variableList) {
        variableList.stream()
                .filter(variable -> {
                    CtExpression<?> assignment = variable.getAssignment();
                    if (assignment instanceof CtFieldReadImpl) {
                        String target = ((CtFieldReadImpl<?>) assignment).getTarget().toString();
                        return variablesNullChecked.contains(target);
                    }
                    return false;
                }).forEach(variable -> {
                    CtFieldReadImpl assignment = (CtFieldReadImpl<?>) variable.getAssignment();
                    CtBinaryOperator<Boolean> checkNull = addNullCheck(factory, assignment);
                    CtIf anIf = factory.createIf();
                    anIf.setCondition(checkNull);

                    CtAssignment<?, ?> thenStatement = factory.createVariableAssignment(variable.getReference(), false, assignment);
                    anIf.setThenStatement(thenStatement);

                    String variableName = variable.getSimpleName();
                    CtTypeReference variableType = variable.getType();
                    CtExpression<?> defaultValue = null;
                    if (variableType.isPrimitive()) {
                        if (variableType.getSimpleName().equals("String")) {
                            defaultValue = factory.createLiteral("");
                        } else if (variableType.getSimpleName().equals("boolean")) {
                            defaultValue = factory.createLiteral(false);
                        } else
                            defaultValue = factory.createLiteral(0);
                    }

                    CtLocalVariable<?> localVariable = factory.createLocalVariable(variableType, variableName, defaultValue);

                    // Needs to follow this order to ensure that the declaration of the variable comes first
                    variable.insertAfter(anIf);
                    variable.replace(localVariable);
                });
    }

    private static void verifyNullCheck(CtElement leftHandOperator, CtElement rightHandOperator) {
        if (leftHandOperator instanceof CtBinaryOperator) {
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) leftHandOperator;
            CtElement leftElement = binaryOperator.getLeftHandOperand();
            CtElement rightElement = binaryOperator.getRightHandOperand();
            verifyNullCheck(leftElement, rightElement);
        } else if (leftHandOperator instanceof CtLiteralImpl && ((CtLiteralImpl<?>)leftHandOperator).getValue() == null) {
            variablesNullChecked.add(rightHandOperator.toString());
        }

        if (rightHandOperator instanceof CtBinaryOperator) {
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) rightHandOperator;
            CtElement leftElement = binaryOperator.getLeftHandOperand();
            CtElement rightElement = binaryOperator.getRightHandOperand();
            verifyNullCheck(leftElement, rightElement);
        }  else if (rightHandOperator instanceof CtLiteralImpl && ((CtLiteralImpl<?>)rightHandOperator).getValue() == null) {
            variablesNullChecked.add(leftHandOperator.toString());
        }
    }

    private static CtBinaryOperator<Boolean> addNullCheck(Factory factory, CtExpression<?> variable) {
        CtBinaryOperator<Boolean> newCondition = null;
        if (variablesNullChecked.contains(variable.toString())) {
            newCondition = factory.createBinaryOperator(variable, factory.createCodeSnippetExpression("null"), BinaryOperatorKind.NE);
        }
        return newCondition;
    }

    private static CtBinaryOperator<Boolean> addLengthCheck(Factory factory, CtArrayReadImpl<?> arrayRead) {
        CtExpression<?> target = arrayRead.getTarget();
        CtExpression<Integer> indexExpression = arrayRead.getIndexExpression();
        if (indexExpression instanceof CtUnaryOperator) {
            logger.info("Modify the expression {}", indexExpression);
            indexExpression = ((CtUnaryOperator<Integer>) indexExpression).getOperand();
        }

        CtFieldReference<Integer> fieldReference = factory.createFieldReference();
        CtTypeReference<Integer> typeReference = factory.Type().INTEGER;
        fieldReference.setDeclaringType(typeReference);
        fieldReference.setSimpleName("length");
        fieldReference.setType(typeReference);

        CtFieldRead<Integer> fieldRead = factory.createFieldRead();
        fieldRead.setTarget(target);
        fieldRead.setVariable(fieldReference);
        CtBinaryOperator<Boolean> lengthCheck = factory.createBinaryOperator(indexExpression, fieldRead, BinaryOperatorKind.LT);
        CtBinaryOperator<Boolean> nullCheck = addNullCheck(factory, target);

        if (nullCheck != null) {
            return factory.createBinaryOperator(nullCheck, lengthCheck, BinaryOperatorKind.AND);
        }
        return lengthCheck;
    }
}