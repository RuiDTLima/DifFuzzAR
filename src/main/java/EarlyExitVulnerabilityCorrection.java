import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.ReturnOrThrowFilter;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.NamingConvention;
import java.util.*;
import java.util.stream.Stream;

public class EarlyExitVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(EarlyExitVulnerabilityCorrection.class);
    private static final ArrayList<String> VARIABLES_NULL_CHECKED = new ArrayList<>();
    private static final HashMap<String, List<CtExpression<Boolean>>> PROTECTED_VARIABLES = new HashMap<>();

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod) {
        NamingConvention.resetCounter();
        List<CtCFlowBreak> returnList = modifiedMethod.getElements(new ReturnOrThrowFilter());
        returnList.removeIf(returnOrThrow -> !(returnOrThrow instanceof CtReturnImpl));

        int numberOfReturns = returnList.size();
        if (numberOfReturns <= 1) {
            return;
        }

        logger.info("The method suffers from early-exit timing side-channel vulnerability since it has {} exit points.",
                numberOfReturns);

        List<CtLocalVariable<?>> variableList = modifiedMethod.getElements(new TypeFilter<>(CtLocalVariable.class));
        CtBlock<?> modifiedMethodBody = modifiedMethod.getBody();

        int lastIndex = numberOfReturns - 1;
        CtReturnImpl<?> finalReturnElement = (CtReturnImpl<?>) returnList.get(lastIndex);
        CtExpression<?> returnedExpression = finalReturnElement.getReturnedExpression();

        Optional<CtLocalVariable<?>> optionalReturnAssignment = variableList.stream()
                .filter(it -> it.getReference().toString().matches(".*\\b" + returnedExpression + "\\b.*"))
                .findFirst();

        CtExpression<?> returnElement = findValueToReturn(variableList, returnedExpression, returnedExpression);

        CtLocalVariable variable = createReturnVariable(factory, modifiedMethod.getType(), variableList, modifiedMethodBody,
                optionalReturnAssignment, returnElement);

        Iterator<CtCFlowBreak> returnsIterator = returnList.iterator();

        CtBlock<?> newMethodBody = handleStatements(factory, modifiedMethodBody.iterator(), returnsIterator, variable, modifiedMethodBody, returnElement, false);

        List<CtCFlowBreak> newReturnList = newMethodBody.getElements(new ReturnOrThrowFilter());
        newReturnList.removeIf(returnOrThrow -> !(returnOrThrow instanceof CtReturnImpl));

        if (newReturnList.size() == 0) {
            modifyLastReturn(factory, newMethodBody, variable);
        }

        List<CtLocalVariable<?>> newVariableList = newMethodBody.getElements(new TypeFilter<>(CtLocalVariable.class));

        if (!VARIABLES_NULL_CHECKED.isEmpty()) {
            protectVariableAccess(factory, newVariableList);
        }

        modifiedMethod.setBody(newMethodBody);
    }

    private static CtBlock<?> handleStatements(Factory factory, Iterator<CtStatement> iterator,
                                               Iterator<CtCFlowBreak> returnsIterator,
                                               CtLocalVariable<?> variable,
                                               CtBlock<?> modifiedMethodBody,
                                               CtExpression<?> returnElement,
                                               boolean afterCycleReturn) {

        CtBlock<?> newBody = factory.createBlock();
        while (iterator.hasNext()) {
            CtStatement currentStatement = iterator.next();
            if (currentStatement instanceof CtIf) {
                CtIfImpl ifStatement = (CtIfImpl) currentStatement;
                CtBlock<?> thenStatements = ifStatement.getThenStatement();
                CtBlock<?> elseStatements = ifStatement.getElseStatement();

                CtIf newIfStatement = factory.createIf();
                newIfStatement.setCondition(ifStatement.getCondition());
                modifyIfCondition(factory, newIfStatement);

                CtBlock<?> newThenBlock = handleStatements(factory, thenStatements.iterator(), returnsIterator, variable, modifiedMethodBody, returnElement, afterCycleReturn);
                newIfStatement.setThenStatement(newThenBlock);
                if (elseStatements != null) {
                    CtBlock<?> newElseBlock = handleStatements(factory, elseStatements.iterator(), returnsIterator, variable, modifiedMethodBody, returnElement, afterCycleReturn);
                    newIfStatement.setElseStatement(newElseBlock);
                }

                newBody.addStatement(newIfStatement);
                afterCycleReturn = false;
            } else if (currentStatement instanceof CtWhile) {
                CtWhileImpl whileStatement = (CtWhileImpl) currentStatement;
                CtWhile newWhileStatement = whileStatement.clone();
                CtExpression<Boolean> stoppingCondition = whileStatement.getLoopingExpression();

                CtLoop newLoop = updateLoop(factory, whileStatement, stoppingCondition);

                CtBlock<?> body = (CtBlock<?>) newLoop.getBody();
                CtBlock<?> newWhileBody = handleStatements(factory, body.iterator(), returnsIterator, variable, modifiedMethodBody, returnElement, afterCycleReturn);

                newWhileStatement.setBody(newWhileBody);
                newBody.addStatement(newWhileStatement);
                afterCycleReturn = true;
            } else if (currentStatement instanceof CtFor) {
                CtForImpl forStatement = (CtForImpl) currentStatement;
                CtFor newForStatement = forStatement.clone();
                CtBlock<?> body = (CtBlock<?>) newForStatement.getBody();
                CtExpression<Boolean> stoppingCondition = forStatement.getExpression();

                if (body.getStatements().size() == 1 && !(body.getStatement(0) instanceof CtIf)) {
                    CtLoop newLoop = updateLoop(factory, forStatement, stoppingCondition);
                    body = (CtBlock<?>) newLoop.getBody();
                }
                CtBlock<?> newForBody = handleStatements(factory, body.iterator(), returnsIterator, variable, modifiedMethodBody, returnElement, afterCycleReturn);

                newForStatement.setBody(newForBody);
                newBody.addStatement(newForStatement);
                afterCycleReturn = false;
            } else if (currentStatement instanceof CtReturnImpl) {
                logger.info("Found a return.");
                returnsIterator.next();
                CtReturnImpl<?> returnStatement = (CtReturnImpl<?>) currentStatement;
                boolean isLastReturn = !returnsIterator.hasNext();
                CtStatement newStatement = handleReturnStatement(factory, returnStatement, variable, modifiedMethodBody, returnElement, isLastReturn);
                if (afterCycleReturn) {
                    int numberOfStatement = newBody.getStatements().size();
                    newBody.addStatement(numberOfStatement - 1, newStatement);
                } else {
                    newBody.addStatement(newStatement);
                }
                afterCycleReturn = false;
            } else if (currentStatement instanceof CtLocalVariable) {
                CtLocalVariable<?> localVariable = (CtLocalVariable<?>) currentStatement;
                CtExpression<?> assignment = localVariable.getAssignment();
                if (assignment instanceof CtBinaryOperator) {   //  TODO add possibility of multiple binary operators.
                    CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) assignment;
                    CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
                    CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();

                    List<CtExpression<Boolean>> newLeftOperator = null;
                    List<CtExpression<Boolean>> newRightOperator = null;

                    if (PROTECTED_VARIABLES.containsKey(leftHandOperand.toString())) {  // TODO add variable for string.
                        newLeftOperator = PROTECTED_VARIABLES.get(leftHandOperand.toString());
                    }

                    if (PROTECTED_VARIABLES.containsKey(rightHandOperand.toString())) {
                        newRightOperator = PROTECTED_VARIABLES.get(rightHandOperand.toString());
                    }

                    if (newLeftOperator != null && newRightOperator != null && !newLeftOperator.equals(newRightOperator)) {
                        CtExpression<Boolean> newLeftCondition = null;

                        if (newLeftOperator.size() > 1) {
                            for (int i = 0; i < newLeftOperator.size() - 1; i++) {
                                if (newLeftCondition == null) {
                                    CtExpression<Boolean> left = negateCondition(factory, newLeftOperator.get(i));
                                    CtExpression<Boolean> right = negateCondition(factory, newLeftOperator.get(++i));
                                    CtExpression<Boolean> temp = factory.createBinaryOperator(left, right, BinaryOperatorKind.AND);
                                    //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                    newLeftCondition = temp;
                                } else {
                                    CtExpression<Boolean> temp = factory.createBinaryOperator(newLeftCondition, negateCondition(factory, newLeftOperator.get(i)), BinaryOperatorKind.AND);
                                    //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);
                                    newLeftCondition = temp;
                                }
                            }
                        } else {
                            newLeftCondition = negateCondition(factory, newLeftOperator.get(0));  // TODO negate
                        }

                        CtExpression<Boolean> newRightCondition = null;

                        if (newRightOperator.size() > 1) {
                            for (int i = 0; i < newRightOperator.size() - 1; i++) {
                                if (newRightCondition == null) {
                                    CtExpression<Boolean> left = negateCondition(factory, newRightOperator.get(i));
                                    CtExpression<Boolean> right = negateCondition(factory, newRightOperator.get(++i));
                                    CtExpression<Boolean> temp = factory.createBinaryOperator(left, right, BinaryOperatorKind.AND); // TODO variable
                                    //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                    newRightCondition = temp;
                                } else {
                                    CtExpression<Boolean> temp = factory.createBinaryOperator(newRightCondition, negateCondition(factory, newRightOperator.get(i)), BinaryOperatorKind.OR);
                                    //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                    newRightCondition = temp;
                                }
                            }
                        } else {
                            newRightCondition = negateCondition(factory, newRightOperator.get(0));
                        }

                        //CtBinaryOperator<Boolean> newCondition = factory.createBinaryOperator(newLeftOperator, newRightOperator, BinaryOperatorKind.AND);
                        CtBinaryOperator<Boolean> newCondition = factory.createBinaryOperator(newLeftCondition, newRightCondition, BinaryOperatorKind.AND);
                        protectLocalVariable(factory, newBody, localVariable, newCondition);
                    } else if (newLeftOperator != null) {
                        CtExpression<Boolean> newLeftCondition = null;

                        for (int i = 0; i < newLeftOperator.size() - 1; i++) {
                            if (newLeftCondition == null) {
                                CtExpression<Boolean> left = negateCondition(factory, newLeftOperator.get(i));
                                CtExpression<Boolean> right = negateCondition(factory, newLeftOperator.get(++i));
                                CtExpression<Boolean> temp = factory.createBinaryOperator(left, right, BinaryOperatorKind.AND);
                                //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                newLeftCondition = temp;
                            } else {
                                CtExpression<Boolean> temp = factory.createBinaryOperator(newLeftCondition, negateCondition(factory, newLeftOperator.get(i)), BinaryOperatorKind.AND);
                                //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                newLeftCondition = temp;
                            }
                        }
                        protectLocalVariable(factory, newBody, localVariable, newLeftCondition);
                    } else if (newRightOperator != null) {
                        CtExpression<Boolean> newRightCondition = null;

                        for (int i = 0; i < newRightOperator.size() - 1; i++) {
                            if (newRightCondition == null) {
                                CtExpression<Boolean> left = negateCondition(factory, newRightOperator.get(i));
                                CtExpression<Boolean> right = negateCondition(factory, newRightOperator.get(++i));
                                CtExpression<Boolean> temp = factory.createBinaryOperator(left, right, BinaryOperatorKind.AND);
                                //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                newRightCondition = temp;
                            } else {
                                CtExpression<Boolean> temp = factory.createBinaryOperator(newRightCondition, negateCondition(factory, newRightOperator.get(i)), BinaryOperatorKind.AND);
                                //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, temp);

                                newRightCondition = temp;
                            }
                        }
                        protectLocalVariable(factory, newBody, localVariable, newRightCondition);
                    } else {
                        newBody.addStatement(currentStatement.clone());
                    }
                } else {
                    newBody.addStatement(currentStatement.clone());
                }
                afterCycleReturn = false;
            } else {
                newBody.addStatement(currentStatement.clone());
                afterCycleReturn = false;
            }
        }
        return newBody;
    }

    private static CtUnaryOperator<Boolean> negateCondition(Factory factory, CtExpression<Boolean> temp) {
        CtUnaryOperator<Boolean> unaryOperator = factory.createUnaryOperator();
        unaryOperator.setKind(UnaryOperatorKind.NOT);
        unaryOperator.setOperand(temp);
        return unaryOperator;
    }

    private static void protectLocalVariable(Factory factory, CtBlock<?> newBody, CtLocalVariable<?> localVariable, CtExpression<Boolean> condition) {
        CtLocalVariable<?> newLocalVariable = localVariable.clone();
        CtTypeReference declaringType = newLocalVariable.getType();
        CtExpression oldAssignment = localVariable.getAssignment();

        if (declaringType.isPrimitive()) {
            CtExpression assignment;
            switch (declaringType.getSimpleName()) {
                case "String":
                    assignment = factory.createLiteral("");
                    break;
                case "boolean":
                    assignment = factory.createLiteral(false);
                    break;
                default :
                    assignment = factory.createLiteral(0);
                    break;
            }

            newLocalVariable.setAssignment(assignment);
            newBody.addStatement(newLocalVariable);
        }

        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(newLocalVariable.getReference(), false, oldAssignment);
        variableAssignment.setType(declaringType);

        CtBlock<?> newThenBlock = factory.createBlock();
        newThenBlock.addStatement(variableAssignment);

        //  TODO attempt a more correct negation
        //CtUnaryOperator<Boolean> unaryOperator = negateCondition(factory, condition);

        CtIf newIf = factory.createIf();
        newIf.setCondition(condition);
        newIf.setThenStatement(newThenBlock);

        newBody.addStatement(newIf);
    }

    //  TODO check stopping condition and body.
    private static CtLoop updateLoop(Factory factory, CtLoop loop, CtExpression<Boolean> stoppingCondition) {
        boolean modified = false;
        CtLoop newLoop = loop.clone();
        if (stoppingCondition instanceof CtBinaryOperator) {    //  TODO check for multiple binaryOperators.
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) stoppingCondition;
            CtBinaryOperator<Boolean> newStoppingCondition;
            CtExpression<?> newRightHandOperand = null;
            CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
            CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();

            if (PROTECTED_VARIABLES.containsKey(rightHandOperand.toString())) {
                CtBinaryOperator<?> clone = binaryOperator.clone();
                CtExpression<?> otherVariable = modifyHandOperand(rightHandOperand);
                newRightHandOperand = clone.setRightHandOperand(otherVariable);
                modified = true;
            } else if (PROTECTED_VARIABLES.containsKey(leftHandOperand.toString())){
                CtBinaryOperator<?> clone = binaryOperator.clone();
                CtExpression<?> otherVariable = modifyHandOperand(leftHandOperand);
                newRightHandOperand = clone.setLeftHandOperand(otherVariable);
                modified = true;
            }

            if (modified) {
                newStoppingCondition = factory.createBinaryOperator();
                newStoppingCondition.setKind(BinaryOperatorKind.AND);
                newStoppingCondition.setLeftHandOperand(binaryOperator.clone());
                newStoppingCondition.setRightHandOperand(newRightHandOperand);
                CtIf newIf = factory.createIf();
                newIf.setCondition(newStoppingCondition);
                newIf.setThenStatement(loop.getBody());
                newLoop.setBody(newIf);
            }
        }
        return newLoop;
    }

    private static CtExpression<?> modifyHandOperand(CtExpression<?> handOperand) {
        CtBinaryOperator<Boolean> booleanCtExpression = (CtBinaryOperator<Boolean>) PROTECTED_VARIABLES.get(handOperand.toString());
        CtExpression<?> leftHandOperand = booleanCtExpression.getLeftHandOperand();
        CtExpression<?> rightHandOperand = booleanCtExpression.getRightHandOperand();
        CtExpression<?> otherVariable;
        if (leftHandOperand.equals(handOperand)) {
            otherVariable = rightHandOperand;
        } else {
            otherVariable = leftHandOperand;
        }
        return otherVariable;
    }

    private static CtStatement handleReturnStatement(Factory factory, CtReturnImpl<?> returnStatement,
                                                            CtLocalVariable<?> variable,
                                                            CtBlock<?> modifiedMethodBody,
                                                            CtExpression<?> returnElement,
                                                            boolean isLastReturn) {

        CtElement parentElement = returnStatement.getParent().getParent();
        if (parentElement instanceof CtIfImpl) {
            CtIfImpl ifStatement = (CtIfImpl) parentElement;
            CtExpression<Boolean> condition = ifStatement.getCondition();
            saveIfVariables(condition, condition);
            modifyIfCondition(factory, ifStatement);
        } else if (isLastReturn) {
            return modifyLastReturn(factory, returnElement, variable, returnStatement);
        }
        return alterReturnExpression(factory, variable, returnStatement);
    }

    private static void saveIfVariables(CtExpression<Boolean> ifCondition, CtExpression<?> currentCondition) {
        if (currentCondition instanceof CtBinaryOperator) {
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) currentCondition;
            CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
            CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();
            saveIfVariables(ifCondition, leftHandOperand);
            saveIfVariables(ifCondition, rightHandOperand);
        } else if (currentCondition instanceof CtVariableRead) {
            CtVariableRead<?> variableRead = (CtVariableRead<?>) currentCondition;
            String simpleName = variableRead.getVariable().getSimpleName();
            List<CtExpression<Boolean>> conditionsList;
            if (PROTECTED_VARIABLES.containsKey(simpleName)) {
                conditionsList = PROTECTED_VARIABLES.get(simpleName);
            } else {
                conditionsList = new ArrayList<>();
            }
            conditionsList.add(ifCondition);
            PROTECTED_VARIABLES.put(simpleName, conditionsList);
        }
    }

    private static CtAssignment<?, ?> alterReturnExpression(Factory factory, CtLocalVariable variable, CtReturnImpl<?> returnImpl) {
        CtExpression<?> returnedValue = returnImpl.getReturnedExpression();
        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(variable.getReference(), false, returnedValue);
        variableAssignment.setType(variable.getType());
        return variableAssignment;
    }

    /**
     * Determines if the final return, returns the result of a method invocation. If so, it is important to ensure that
     * all arguments passed to the method are available at the start of the method execution. Otherwise the created variable
     * will be declared without a starting value.
     * @param variableList the list of variables in the method.
     * @param returnedExpression the expression returned in the last return of the method.
     * @param finalReturn   The value returned in the last return of the method.
     * @return The value to initiate the new variable with.
     */
    private static CtExpression<?> findValueToReturn(List<CtLocalVariable<?>> variableList,
                                                     CtExpression<?> returnedExpression,
                                                     CtExpression<?> finalReturn) {
        CtExpression<?> returnElement;
        if (returnedExpression instanceof CtInvocation) {
            Stream<?> lastReturnInvocationArguments = ((CtInvocationImpl<?>) returnedExpression)
                    .getArguments()
                    .stream()
                    .flatMap(elem -> Arrays.stream(elem.toString().split("\\.")).limit(1));

            if (lastReturnInvocationArguments.noneMatch(argument -> variableList.stream().anyMatch(variable -> variable.getReference().getDeclaration().getSimpleName().equals(argument)))) {
                returnElement = finalReturn;
            } else
                returnElement = null;
        } else if (returnedExpression instanceof CtBinaryOperator)
            returnElement = null;
        else
            returnElement = finalReturn;
        return returnElement;
    }

    /**
     * Method where the variable used to contain the value to be returned in the end of the method is created. Or the existing
     * variable to be return is added to the beginning of the method to allow assignment anywhere in the method where a return
     * exists.
     * @param factory The factory used to create code snippets to add.
     * @param methodReturnType The return type of the method to modify.
     * @param variableList  The list of variables created inside the method
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param optionalReturnAssignment  If a value is present it means that a new variable to be returned needs to be created.
     * @param returnElement The element to return.
     * @return The variable to be returned, either an existing variable or the newly created one.
     */
    private static CtLocalVariable<?> createReturnVariable(Factory factory, CtTypeReference<?> methodReturnType,
                                                           List<CtLocalVariable<?>> variableList,
                                                           CtBlock<?> modifiedMethodBody,
                                                           Optional<CtLocalVariable<?>> optionalReturnAssignment,
                                                           CtExpression<?> returnElement) {

        CtLocalVariable<?> newVariable = null;

        if (!optionalReturnAssignment.isPresent()) {
            CtExpression<?> defaultExpression;
            if (returnElement == null) {
                defaultExpression = null;
            } else {
                CtElement returnParent = returnElement.getParent().getParent().getParent();
                if (returnParent instanceof CtIf) {
                    defaultExpression = null;
                } else {
                    defaultExpression = produceDefaultExpression(variableList, returnElement);
                }
            }

            newVariable = NamingConvention.produceNewVariable(factory, methodReturnType, defaultExpression);
            modifiedMethodBody.addStatement(0, newVariable);
            logger.info("Added the instruction {}.", newVariable);
        } else {
            CtLocalVariable<?> returnAssignmentToRemove = optionalReturnAssignment.get();
            CtLocalVariable<?> returnAssignmentToAdd = returnAssignmentToRemove.clone();

            if (returnAssignmentToRemove.getDefaultExpression() instanceof CtNewArrayImpl) {    // In response to themis_dynatable_unsafe
                List<CtExpression<Integer>> dimensionExpressions = ((CtNewArrayImpl<?>) returnAssignmentToRemove.getDefaultExpression())
                        .getDimensionExpressions();

                for (CtLocalVariable<?> variable : variableList) {
                    if (dimensionExpressions.stream().anyMatch(arraySize -> variable.getSimpleName().equals(arraySize.toString()))) {
                        String returnName = returnAssignmentToRemove.getSimpleName();
                        CtExpression assignment = returnAssignmentToRemove.getAssignment();
                        CtTypeReference<?> returnType = returnAssignmentToRemove.getType();

                        newVariable = factory.createLocalVariable(returnType, returnName, null);
                        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(newVariable.getReference(), false, assignment);
                        returnAssignmentToRemove.replace(variableAssignment);
                        modifiedMethodBody.addStatement(0, newVariable);
                        break;
                    }
                }
            } else {
                modifiedMethodBody.removeStatement(returnAssignmentToRemove);
                modifiedMethodBody.addStatement(0, returnAssignmentToAdd);
                newVariable = returnAssignmentToAdd;
            }
        }
        return newVariable;
    }

    private static CtExpression<?> produceDefaultExpression(List<CtLocalVariable<?>> variableList, CtExpression<?> returnElement) {
        if (returnElement instanceof CtInvocationImpl) {
            CtInvocationImpl<?> invocation = (CtInvocationImpl<?>) returnElement;
            List<String> usedVariables = getUsedVariables(invocation);
            if (variableList.stream().anyMatch(variable -> usedVariables.contains(variable.getSimpleName()))) {
                return null;
            }
        }
        return returnElement;
    }

    private static List<String> getUsedVariables(CtInvocationImpl<?> invocation) {
        List<String> usedVariables = new ArrayList<>();
        CtExpression<?> target = invocation.getTarget();
        if (target instanceof CtInvocationImpl) {
            usedVariables.addAll(getUsedVariables((CtInvocationImpl<?>) target));
        } else {
            usedVariables.add(target.toString());
        }
        List<CtExpression<?>> invocationArguments = invocation.getArguments();
        for (CtExpression<?> invocationArgument : invocationArguments) {
            if (invocationArgument instanceof CtInvocationImpl) {
                usedVariables.addAll(getUsedVariables((CtInvocationImpl<?>) invocationArgument));
            } else {
                usedVariables.add(invocationArgument.toString());
            }
        }
        return usedVariables;
    }

    /**
     * Modifies the condition of the if. This is important when accessing an array, to avoid IndexOutOfBoundsException.
     * Since it is likely that the condition to avoid the IndexOutOfBoundsException no longer work to avoid early-exit
     * timing side-channel.
     * @param factory   The factory used to create code snippets to add.
     * @param ifStatement   The if statement to be modified.
     */
    private static void modifyIfCondition(Factory factory, CtIf ifStatement) {
        if (ifStatement.getCondition() instanceof CtBinaryOperator) {
            boolean modification = false;
            CtBinaryOperator<Boolean> condition = (CtBinaryOperator<Boolean>) ifStatement.getCondition();
            CtExpression<?> leftHandOperator = condition.getLeftHandOperand();
            CtExpression<?> rightHandOperator = condition.getRightHandOperand();
            CtBinaryOperator<Boolean> newLeftHand = null;
            CtBinaryOperator<Boolean> newRightHand = null;

            verifyNullCheck(leftHandOperator, rightHandOperator);

            if (leftHandOperator instanceof CtFieldReadImpl) {
                CtExpression<?> variable = ((CtFieldReadImpl<?>) leftHandOperator).getTarget();
                CtBinaryOperator<Boolean> result = addNullCheck(factory, variable);
                if (result != null) {
                    newLeftHand = result;
                    modification = true;
                }
            } else if (leftHandOperator instanceof CtArrayReadImpl) {
                newLeftHand = addLengthCheck(factory, (CtArrayReadImpl<?>) leftHandOperator);
                modification = true;
            }

            if (rightHandOperator instanceof CtFieldReadImpl) {
                CtExpression<?> variable = ((CtFieldReadImpl<?>) rightHandOperator).getTarget();
                CtBinaryOperator<Boolean> result = addNullCheck(factory, variable);
                if (result != null) {
                    newRightHand = result;
                    modification = true;
                }
            } else if (rightHandOperator instanceof CtArrayReadImpl) {
                newRightHand = addLengthCheck(factory, (CtArrayReadImpl<?>) rightHandOperator);
                modification = true;
            }

            if (modification) {
                CtBinaryOperator<Boolean> addedCondition;
                if (newLeftHand != null && newRightHand != null) {
                    addedCondition = factory.createBinaryOperator(newLeftHand, newRightHand, BinaryOperatorKind.AND);
                } else {
                    addedCondition = newLeftHand != null ? newLeftHand : newRightHand;
                }

                CtBinaryOperator<Boolean> newConditional = factory.createBinaryOperator(addedCondition, condition, BinaryOperatorKind.AND);
                ifStatement.setCondition(newConditional);
            }
        }
    }

    /**
     * Modifies the final return of the vulnerable method. This needs to be different because it will not only eliminate
     * a return expression but modified. If the last return was an expression and it wasn't already assigned to the return
     * variable it is now, and a new return expression is created.
     * @param factory   The factory used to create code snippets to add.
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param variable  The name of the variable to be returned.
     */
    private static void modifyLastReturn(Factory factory, CtBlock<?> modifiedMethodBody,
                                                CtLocalVariable<?> variable){
        CtReturn<?> objectCtReturn = factory.createReturn().setReturnedExpression(factory.createCodeSnippetExpression(variable.getSimpleName()));

        modifiedMethodBody.addStatement(objectCtReturn);
    }

    /**
     * Modifies the final return of the vulnerable method. This needs to be different because it will not only eliminate
     * a return expression but modified. If the last return was an expression and it wasn't already assigned to the return
     * variable it is now, and a new return expression is created.
     * @param factory   The factory used to create code snippets to add.
     * @param returnElement The element to return.
     * @param variable  The name of the variable to be returned.
     * @param returnImpl    The return instruction to be replaced.
     * @return
     */
    private static CtStatement modifyLastReturn(Factory factory,
                                         CtExpression<?> returnElement,
                                         CtLocalVariable<?> variable,
                                         CtReturnImpl<?> returnImpl) {

        CtExpression<?> returnedValue = returnImpl.getReturnedExpression();
        CtReturn<?> objectCtReturn = factory.createReturn().setReturnedExpression(factory.createCodeSnippetExpression(variable.getSimpleName()));

        if (returnElement == null || !returnElement.toString().contains(returnedValue.toString())) {
            return alterReturnExpression(factory, variable, returnImpl);
        } else {
            returnImpl.replace(objectCtReturn);
        }
        return null;
    }

    private static void protectVariableAccess(Factory factory, List<CtLocalVariable<?>> variableList) {
        variableList.stream()
                .filter(variable -> {
                    CtExpression<?> assignment = variable.getAssignment();
                    if (assignment instanceof CtFieldReadImpl) {
                        String target = ((CtFieldReadImpl<?>) assignment).getTarget().toString();
                        return VARIABLES_NULL_CHECKED.contains(target);
                    }
                    return false;
                }).forEach(variable -> {
                    CtFieldReadImpl assignment = (CtFieldReadImpl<?>) variable.getAssignment();
                    CtBinaryOperator<Boolean> checkNull = addNullCheck(factory, assignment.getTarget());
                    CtIf anIf = factory.createIf();
                    CtBlock<?> thenBlock = factory.createBlock();
                    anIf.setCondition(checkNull);

                    CtAssignment thenStatement = factory.createVariableAssignment(variable.getReference(), false, assignment);
                    thenStatement.setType(variable.getType());
                    thenBlock.addStatement(thenStatement);
                    anIf.setThenStatement(thenBlock);

                    String variableName = variable.getSimpleName();
                    CtTypeReference variableType = variable.getType();
                    CtExpression<?> defaultValue = null;
                    if (variableType.isPrimitive()) {
                        if (variableType.getSimpleName().equals("String")) {
                            defaultValue = factory.createLiteral("");
                        } else if (variableType.getSimpleName().equals("boolean")) {
                            defaultValue = factory.createLiteral(false);
                        } else
                            defaultValue = factory.createLiteral(0);
                    }

                    CtLocalVariable<?> localVariable = factory.createLocalVariable(variableType, variableName, defaultValue);

                    // Needs to follow this order to ensure that the declaration of the variable comes first
                    variable.insertAfter(anIf);
                    variable.replace(localVariable);
                });
    }

    private static void verifyNullCheck(CtElement leftHandOperator, CtElement rightHandOperator) {
        if (leftHandOperator instanceof CtBinaryOperator) {
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) leftHandOperator;
            CtElement leftElement = binaryOperator.getLeftHandOperand();
            CtElement rightElement = binaryOperator.getRightHandOperand();
            verifyNullCheck(leftElement, rightElement);
        } else if (leftHandOperator instanceof CtLiteralImpl && ((CtLiteralImpl<?>)leftHandOperator).getValue() == null) {
            VARIABLES_NULL_CHECKED.add(rightHandOperator.toString());
        }

        if (rightHandOperator instanceof CtBinaryOperator) {
            CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) rightHandOperator;
            CtElement leftElement = binaryOperator.getLeftHandOperand();
            CtElement rightElement = binaryOperator.getRightHandOperand();
            verifyNullCheck(leftElement, rightElement);
        }  else if (rightHandOperator instanceof CtLiteralImpl && ((CtLiteralImpl<?>)rightHandOperator).getValue() == null) {
            VARIABLES_NULL_CHECKED.add(leftHandOperator.toString());
        }
    }

    private static CtBinaryOperator<Boolean> addNullCheck(Factory factory, CtExpression<?> variable) {
        CtBinaryOperator<Boolean> newCondition = null;
        if (VARIABLES_NULL_CHECKED.contains(variable.toString())) {
            newCondition = factory.createBinaryOperator(variable, factory.createLiteral(null), BinaryOperatorKind.NE);
        }
        return newCondition;
    }

    private static CtBinaryOperator<Boolean> addLengthCheck(Factory factory, CtArrayReadImpl<?> arrayRead) {
        CtExpression<?> target = arrayRead.getTarget();
        CtExpression<Integer> indexExpression = arrayRead.getIndexExpression();
        if (indexExpression instanceof CtUnaryOperator) {
            logger.info("Modify the expression {}", indexExpression);
            indexExpression = ((CtUnaryOperator<Integer>) indexExpression).getOperand();
        }

        CtFieldReference<Integer> fieldReference = factory.createFieldReference();
        CtTypeReference<Integer> typeReference = factory.Type().INTEGER;
        fieldReference.setDeclaringType(typeReference);
        fieldReference.setSimpleName("length");
        fieldReference.setType(typeReference);

        CtFieldRead<Integer> fieldRead = factory.createFieldRead();
        fieldRead.setTarget(target);
        fieldRead.setVariable(fieldReference);
        CtBinaryOperator<Boolean> lengthCheck = factory.createBinaryOperator(indexExpression, fieldRead, BinaryOperatorKind.LT);
        CtBinaryOperator<Boolean> nullCheck = addNullCheck(factory, target);

        if (nullCheck != null) {
            return factory.createBinaryOperator(nullCheck, lengthCheck, BinaryOperatorKind.AND);
        }
        return lengthCheck;
    }
}