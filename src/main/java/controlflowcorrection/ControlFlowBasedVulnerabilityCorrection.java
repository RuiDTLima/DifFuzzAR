package controlflowcorrection;

import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.ModifyStatementsFunction;
import util.NamingConvention;
import util.TraverseStatementsFunction;
import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final TreeMap<String, String> VARIABLES_TO_ADD = new TreeMap<>();
    private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();

    private static HashMap<Class<?>, TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>>> traverseStatements;
    private static HashMap<Class<?>, ModifyStatementsFunction<CtElement, Factory, CtIfImpl, List<String>, CtStatement>> modifyStatements;

    public static void addToVariablesToAdd(String key, String value) {
        VARIABLES_TO_ADD.put(key, value);
    }

    public static void addToVariablesReplacement(String key, String value) {
        VARIABLES_REPLACEMENT.put(key, value);
    }

    public static boolean containsKeyVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.containsKey(key);
    }

    public static String getValueVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.get(key);
    }

    private static void populateTraverseStatements() {
        traverseStatements = new HashMap<>();
        traverseStatements.put(CtIfImpl.class,            CtIfModification::traverseStatement);
        traverseStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::traverseStatement);
        traverseStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::traverseStatement);
        traverseStatements.put(CtTryImpl.class,           CtTryModification::traverseStatement);
        traverseStatements.put(CtForImpl.class,           CtForModification::traverseStatement);
        traverseStatements.put(CtLoopImpl.class,          CtLoopModification::traverseStatement);
    }

    private static void populateModifyStatements() {
        modifyStatements = new HashMap<>();
        modifyStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::modifyAssignment);
        modifyStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::modifyLocalVariable);
        modifyStatements.put(CtWhileImpl.class,         CtWhileModification::modifyWhile);
        modifyStatements.put(CtIfImpl.class,            CtIfModification::modifyIf);
        modifyStatements.put(CtUnaryOperatorImpl.class, CtUnaryOperatorModification::modifyUnaryOperator);
    }

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        // TODO add validation of control-flow based timing side-channel vulnerability
        logger.info("The method suffers from control-flow based timing side-channel vulnerability.");
        populateTraverseStatements();
        populateModifyStatements();
        List<CtVariable<?>> secretVariables = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (CtVariable<?> secretArgument : secretVariables) {
            logger.info("{} is a secret argument.", secretArgument.getSimpleName());
        }

        List<CtParameter<?>> publicArguments = findPublicArguments(modifiedMethod, vulnerableMethodUsesCases);

        CtBlock<?> methodBody = modifiedMethod.getBody();
        traverseMethodBody(factory, methodBody, secretVariables, publicArguments);

        List<CtLocalVariable<?>> variableList = methodBody.getElements(new TypeFilter<>(CtLocalVariable.class));
        NamingConvention.resetCounter();
        // TODO is it worth to order the list just so that variables appear ordered?
        VARIABLES_TO_ADD.descendingMap().forEach((name, type) -> {
            String key = VARIABLES_REPLACEMENT.getKey(name);
            Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
                    .filter(variable -> variable.getSimpleName().equals(key))
                    .findFirst();
            CtCodeSnippetStatement newVariable;
            if (replacedVariable.isPresent()) {
                CtLocalVariable<?> localVariable = replacedVariable.get();
                CtExpression<?> assignment = localVariable.getDefaultExpression();
                if (assignment == null) {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name);
                } else {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name + " = " + assignment);
                }
            } else {
                newVariable = factory.createCodeSnippetStatement(type + " " + name);
            }
            methodBody.addStatement(0, newVariable);
        });
        // TODO remove clear
        VARIABLES_TO_ADD.clear();
        VARIABLES_REPLACEMENT.clear();
    }

    private static List<CtVariable<?>> findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            String firstUseCaseArgumentsName = firstUseCaseArgumentsNames[idx];
            if (!firstUseCaseArgumentsName.equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtVariable<?>> secretArguments = new ArrayList<>(secretArgumentsIndex.size());

        for (Integer argumentsIndex : secretArgumentsIndex) {
            secretArguments.add(parameters.get(argumentsIndex));
        }
        return secretArguments;
    }

    private static List<CtParameter<?>> findPublicArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> publicArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is public.", idx);
                publicArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtParameter<?>> publicArguments = new ArrayList<>(publicArgumentsIndex.size());

        for (Integer argumentsIndex : publicArgumentsIndex) {
            publicArguments.add(parameters.get(argumentsIndex));
        }
        return publicArguments;
    }

    public static void traverseMethodBody(Factory factory, CtBlock<?> methodBody, List<CtVariable<?>> secretVariables, List<CtParameter<?>> publicArguments) {
        for (CtStatement statement : methodBody) {
            TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>> function = traverseStatements.get(statement.getClass());
            if (function != null)
                function.apply(statement, factory, secretVariables, publicArguments);
        }
    }

    static boolean usesSecret(String statement, List<CtVariable<?>> dependableVariables) {
        for (CtVariable<?> dependableVariable : dependableVariables) {
            if (Arrays.stream(statement.split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + dependableVariable.getSimpleName() + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    static CtStatementList modifyStatements(Factory factory, List<CtStatement> statements, CtIfImpl initialStatement, List<String> dependableVariables) {
        CtStatementList statementList = new CtStatementListImpl<>();
        for (CtElement element : statements) {
            CtStatement statement = null;
            ModifyStatementsFunction<CtElement, Factory, CtIfImpl, List<String>, CtStatement> function = modifyStatements.get(element.getClass());

            if (function != null) {
                CtStatement returnedStatement = function.apply(element, factory, initialStatement, dependableVariables);
                if (returnedStatement instanceof CtBlock) {
                    CtBlock<?> block = (CtBlock<?>) returnedStatement;
                    block.getStatements().forEach(statementList::addStatement);
                } else {
                    statement = returnedStatement;
                }
            }
            statementList.addStatement(statement);
        }
        return statementList;
    }
}