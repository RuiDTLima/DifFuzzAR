package controlflowcorrection;

import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.CustomFunction;

import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final String NAME_FOR_VARIABLE = "$";
    private static final TreeMap<String, String> VARIABLES_TO_ADD = new TreeMap<>();
    private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();
    private static int counter = 0;

    //private static HashMap<Class<?>, CustomFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>>> modifyStatements;

    public static String getNameForVariable() {
        return NAME_FOR_VARIABLE;
    }

    public static int increaseCounter() {
        return ++counter;
    }

    public static int getCounter() {
        return counter;
    }

    public static void addToVariablesToAdd(String key, String value) {
        VARIABLES_TO_ADD.put(key, value);
    }

    public static void addToVariablesReplacement(String key, String value) {
        VARIABLES_REPLACEMENT.put(key, value);
    }

    public static boolean containsKeyVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.containsKey(key);
    }

    public static String getValueVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.get(key);
    }

    /*private static void populateModifyStatements() {
        modifyStatements = new HashMap<>();
        modifyStatements.put(CtIfImpl.class, CtIfModification::traverseStatement);
        modifyStatements.put(CtAssignmentImpl.class, CtAssignmentModification::traverseStatement);
        modifyStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::traverseStatement);
        modifyStatements.put(CtTryImpl.class, CtTryModification::traverseStatement);
        modifyStatements.put(CtForImpl.class, CtForModification::traverseStatement);
        modifyStatements.put(CtLoopImpl.class, CtLoopModification::traverseStatement);
    }*/

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        //populateModifyStatements();
        List<CtVariable<?>> secretVariables = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (CtVariable<?> secretArgument : secretVariables) {
            logger.info("{} is a secret argument.", secretArgument.getSimpleName());
        }

        List<CtParameter<?>> publicArguments = findPublicArguments(modifiedMethod, vulnerableMethodUsesCases);

        CtBlock<?> methodBody = modifiedMethod.getBody();
        traverseMethodBody(factory, methodBody, secretVariables, publicArguments);

        List<CtLocalVariable<?>> variableList = methodBody.getElements(new TypeFilter<>(CtLocalVariable.class));
        counter = 0;
        // TODO is it worth to order the list just so that variables appear ordered?
        VARIABLES_TO_ADD.descendingMap().forEach((name, type) -> {
            String key = VARIABLES_REPLACEMENT.getKey(name);
            Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
                    .filter(variable -> variable.getSimpleName().equals(key))
                    .findFirst();
            CtCodeSnippetStatement newVariable;
            if (replacedVariable.isPresent()) {
                CtLocalVariable<?> localVariable = replacedVariable.get();
                CtExpression<?> assignment = localVariable.getDefaultExpression();
                if (assignment == null) {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name);
                } else {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name + " = " + assignment);
                }
            } else {
                newVariable = factory.createCodeSnippetStatement(type + " " + name);
            }
            methodBody.addStatement(0, newVariable);
        });
        // TODO remove clear
        VARIABLES_TO_ADD.clear();
        VARIABLES_REPLACEMENT.clear();
    }

    private static List<CtVariable<?>> findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            String firstUseCaseArgumentsName = firstUseCaseArgumentsNames[idx];
            if (!firstUseCaseArgumentsName.equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtVariable<?>> secretArguments = new ArrayList<>(secretArgumentsIndex.size());

        for (Integer argumentsIndex : secretArgumentsIndex) {
            secretArguments.add(parameters.get(argumentsIndex));
        }
        return secretArguments;
    }

    private static List<CtParameter<?>> findPublicArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> publicArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is public.", idx);
                publicArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtParameter<?>> publicArguments = new ArrayList<>(publicArgumentsIndex.size());

        for (Integer argumentsIndex : publicArgumentsIndex) {
            publicArguments.add(parameters.get(argumentsIndex));
        }
        return publicArguments;
    }

    public static void traverseMethodBody(Factory factory, CtBlock<?> methodBody, List<CtVariable<?>> secretVariables, List<CtParameter<?>> publicArguments) {
        for (CtStatement statement : methodBody) {
            /*CustomFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>> function = modifyStatements.get(statement.getClass());
            if (function != null)
                function.apply(statement, factory, secretVariables, publicArguments);*/
            if (statement instanceof CtIfImpl) {
                CtIfImpl ifStatement = (CtIfImpl) statement;
                CtIfModification.traverseStatement(ifStatement, factory, secretVariables, publicArguments);
            } else if (statement instanceof CtAssignment) {
                CtAssignment<?, ?> assignmentStatement = (CtAssignment<?, ?>) statement;
                CtAssignmentModification.traverseStatement(assignmentStatement, factory, secretVariables);
            } else if (statement instanceof CtLocalVariable) {
                CtLocalVariable<?> localVariable = (CtLocalVariable<?>) statement;
                CtLocalVariableModification.traverseStatement(localVariable, secretVariables);
            } else if (statement instanceof CtTry) {
                CtTry tryStatement = (CtTry) statement;
                CtTryModification.traverseStatement(tryStatement, factory, secretVariables, publicArguments);
            } else if (statement instanceof CtFor) {
                CtFor ctFor = (CtFor) statement;
                CtForModification.traverseStatement(ctFor, factory, secretVariables, publicArguments);
            } else if (statement instanceof CtLoop){
                CtLoop ctLoop = (CtLoop) statement;
                CtLoopModification.traverseStatement(ctLoop, factory, secretVariables, publicArguments);
            }
        }
    }

    static boolean usesSecret(String statement, List<CtVariable<?>> dependableVariables) {
        for (CtVariable<?> dependableVariable : dependableVariables) {
            if (Arrays.stream(statement.split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + dependableVariable.getSimpleName() + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    static CtStatementList modifyStatements(Factory factory, List<CtStatement> statements, CtIfImpl initialStatement, List<String> dependableVariables) {
        CtStatementList statementList = new CtStatementListImpl<>();
        for (CtElement element : statements) {
            CtStatement statement = null;
            if (element instanceof CtAssignmentImpl) {
                logger.info("Element is an assignment.");
                statement = CtAssignmentModification.modifyAssignment(factory, (CtAssignmentImpl<?, ?>) element);
            } else if (element instanceof CtLocalVariable) {
                logger.info("Element is a local variable.");
                statement = CtLocalVariableModification.modifyLocalVariable(dependableVariables, (CtLocalVariable<?>) element);
            } else if (element instanceof CtWhile) {
                logger.info("Element is a while block.");
                statement = CtWhileModification.modifyWhile(factory, initialStatement, (CtWhile) element, dependableVariables);
            } else if (element instanceof CtIf) {
                logger.info("Element is an if block.");
                CtIfModification.modifyIf(factory, initialStatement, dependableVariables, statementList, (CtIfImpl) element);
            } else if (element instanceof CtUnaryOperator) {
                logger.info("Element is a unary operator.");
                statement = CtUnaryOperatorModification.modifyUnaryOperator(factory, (CtUnaryOperator<?>) element);
            }
            statementList.addStatement(statement);
        }
        return statementList;
    }
}