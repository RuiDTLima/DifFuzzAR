package controlflowcorrection;

import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.ModifyStatementsFunction;
import util.NamingConvention;
import util.TraverseStatementsFunction;
import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final TreeMap<String, Pair<CtTypeReference<?>, CtExpression<?>>> VARIABLES_TO_ADD = new TreeMap<>();
    private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();
    private static HashMap<Class<?>, TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>, CtBlock<?>[]>> traverseStatements;
    private static HashMap<Class<?>, ModifyStatementsFunction<CtElement, Factory, CtIfImpl, List<String>, List<CtVariable<?>>, CtStatement[]>> modifyStatements;

    public static void addToVariablesToAdd(String name, CtTypeReference<?> type, CtExpression<?> defaultExpression) {
        Pair<CtTypeReference<?>, CtExpression<?>> value = new ImmutablePair<>(type, defaultExpression);
        VARIABLES_TO_ADD.put(name, value);
    }

    public static void addToVariablesReplacement(String key, String value) {
        VARIABLES_REPLACEMENT.put(key, value);
    }

    public static boolean containsKeyVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.containsKey(key);
    }

    public static String getValueVariablesReplacement(String key) {
        return VARIABLES_REPLACEMENT.get(key);
    }

    private static void populateTraverseStatements() {
        traverseStatements = new HashMap<>();
        traverseStatements.put(CtIfImpl.class,            CtIfModification::traverseStatement);
        traverseStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::traverseStatement);
        traverseStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::traverseStatement);
        traverseStatements.put(CtTryImpl.class,           CtTryModification::traverseStatement);
        traverseStatements.put(CtForImpl.class,           CtForModification::traverseStatement);
        traverseStatements.put(CtLoopImpl.class,          CtLoopModification::traverseStatement);
    }

    private static void populateModifyStatements() {
        modifyStatements = new HashMap<>();
        modifyStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::modifyAssignment);
        modifyStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::modifyLocalVariable);
        modifyStatements.put(CtWhileImpl.class,         CtWhileModification::modifyWhile);
        modifyStatements.put(CtIfImpl.class,            CtIfModification::modifyIf);
        modifyStatements.put(CtUnaryOperatorImpl.class, CtUnaryOperatorModification::modifyUnaryOperator);
        modifyStatements.put(CtInvocationImpl.class,    CtInvocationModification::modifyInvocation);
    }

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        // TODO add validation of control-flow based timing side-channel vulnerability
        logger.info("The method suffers from control-flow based timing side-channel vulnerability.");
        populateTraverseStatements();
        populateModifyStatements();
        List<CtVariable<?>> secretVariables = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (CtVariable<?> secretArgument : secretVariables) {
            logger.info("{} is a secret argument.", secretArgument.getSimpleName());
        }

        List<CtParameter<?>> publicArguments = findPublicArguments(modifiedMethod, vulnerableMethodUsesCases);

        CtBlock<?> methodBody = modifiedMethod.getBody();
        CtBlock<?>[] newMethodBodies = traverseMethodBody(factory, methodBody, secretVariables, publicArguments);

        CtBlock<?> newMethodBody = newMethodBodies[0];
        newMethodBody.setFactory(methodBody.getFactory());

        List<CtLocalVariable<?>> variableList = newMethodBody.getElements(new TypeFilter<>(CtLocalVariable.class));

        NamingConvention.resetCounter();
        // TODO is it worth to order the list just so that variables appear ordered?
        addNewVariables(factory, newMethodBody, variableList);
        // TODO remove clear
        VARIABLES_TO_ADD.clear();
        VARIABLES_REPLACEMENT.clear();
        modifiedMethod.setBody(newMethodBody);
    }

    private static List<CtVariable<?>> findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            String firstUseCaseArgumentsName = firstUseCaseArgumentsNames[idx];
            if (!firstUseCaseArgumentsName.equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtVariable<?>> secretArguments = new ArrayList<>(secretArgumentsIndex.size());

        for (Integer argumentsIndex : secretArgumentsIndex) {
            secretArguments.add(parameters.get(argumentsIndex));
        }
        return secretArguments;
    }

    private static List<CtParameter<?>> findPublicArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> publicArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is public.", idx);
                publicArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtParameter<?>> publicArguments = new ArrayList<>(publicArgumentsIndex.size());

        for (Integer argumentsIndex : publicArgumentsIndex) {
            publicArguments.add(parameters.get(argumentsIndex));
        }
        return publicArguments;
    }

    static CtBlock<?>[] traverseMethodBody(Factory factory, CtBlock<?> methodBody, List<CtVariable<?>> secretVariables, List<CtParameter<?>> publicArguments) {
        CtBlock<?>[] statementLists = new CtBlock[2];

        CtBlock<?> oldStatementsList = new CtBlockImpl<>();
        CtBlock<?> newStatementsList = new CtBlockImpl<>();

        statementLists[0] = oldStatementsList;
        statementLists[1] = newStatementsList;

        for (CtStatement statement : methodBody) {
            TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>, CtBlock<?>[]> function = traverseStatements.get(statement.getClass());
            if (function != null) {
                CtBlock<?>[] returnedStatements = function.apply(statement, factory, secretVariables, publicArguments);

                CtBlock<?> oldBlock = returnedStatements[0];
                oldBlock.getStatements().forEach(element -> statementLists[0].addStatement(element.clone()));

                CtBlock<?> newBlock = returnedStatements[1];
                newBlock.getStatements().forEach(element -> statementLists[1].addStatement(element.clone()));
            } else {
                statementLists[0].addStatement(statement.clone());
            }
        }
        return statementLists;
    }

    private static void addNewVariables(Factory factory, CtBlock<?> newMethodBody, List<CtLocalVariable<?>> variableList) {
        VARIABLES_TO_ADD.descendingMap().forEach((name, value) -> {
            CtTypeReference type = value.getLeft();
            CtExpression<?> defaultExpression = value.getRight();
            CtLocalVariable<?> newVariable;
            boolean created = false;
            if (defaultExpression == null) {
                CtExpression<?> assignment;
                String replacementKey = VARIABLES_REPLACEMENT.getKey(name);
                Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
                        .filter(variable -> variable.getSimpleName().equals(replacementKey))
                        .findFirst();
                if (replacedVariable.isPresent()) {
                    CtLocalVariable<?> localVariable = replacedVariable.get();
                    assignment = localVariable.getDefaultExpression();
                } else {
                    assignment = null;
                }
                newVariable = factory.createLocalVariable(type, name, assignment);
            } else {
                newVariable = factory.createLocalVariable(type, name, defaultExpression);
                if (defaultExpression instanceof CtConstructorCall) {
                    CtConstructorCall<?> constructorCall = (CtConstructorCall<?>) defaultExpression;
                    List<CtExpression<?>> arguments = constructorCall.getArguments();
                    for (CtExpression<?> argument : arguments) {
                        created = createVariable(variableList, newVariable, argument.toString());
                    }
                } else if (defaultExpression instanceof CtVariableReadImpl) {
                    String variableRead = ((CtVariableReadImpl<?>) defaultExpression).getVariable().getSimpleName();
                    created = createVariable(variableList, newVariable, variableRead);
                } else if (defaultExpression instanceof CtVariableWrite) {
                    String variableRead = ((CtVariableWriteImpl<?>) defaultExpression).getVariable().getSimpleName();
                    created = createVariable(variableList, newVariable, variableRead);
                }
            }

            if (!created) {
                newMethodBody.addStatement(0, newVariable);
            }
        });
    }

    private static boolean createVariable(List<CtLocalVariable<?>> variableList, CtLocalVariable<?> newVariable, String variableRead) {
        boolean created = false;
        Optional<CtLocalVariable<?>> usedVariable = variableList.stream().filter(variable -> variable.getSimpleName().equals(variableRead)).findFirst();

        if (usedVariable.isPresent()) {
            CtLocalVariable<?> localVariable = usedVariable.get();
            localVariable.insertAfter(newVariable);
            created = true;
        }
        return created;
    }

    static boolean usesSecret(String statement, List<CtVariable<?>> secretVariables) {
        for (CtVariable<?> secretVariable : secretVariables) {
            if (Arrays.stream(statement.split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + secretVariable.getSimpleName() + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    // index 0 -> sameElement; index 1 -> newElement.
    static CtStatementList[] modifyStatements(Factory factory, List<CtStatement> statements, CtIfImpl initialStatement, List<String> dependableVariables, List<CtVariable<?>> secretVariables) {
        CtStatementList[] statementLists = new CtStatementList[2];

        CtStatementList oldStatementsList = new CtStatementListImpl<>();
        CtStatementList newStatementsList = new CtStatementListImpl<>();

        statementLists[0] = oldStatementsList;
        statementLists[1] = newStatementsList;
        for (CtElement element : statements) {
            ModifyStatementsFunction<CtElement, Factory, CtIfImpl, List<String>, List<CtVariable<?>>, CtStatement[]> function = modifyStatements.get(element.getClass());

            if (function != null) {
                CtStatement[] returnedStatements = function.apply(element, factory, initialStatement, dependableVariables, secretVariables);

                if (returnedStatements == null) {
                    statementLists[0].addStatement(null);
                } else if (returnedStatements[0] instanceof CtBlock) {
                    CtBlock<?> oldBlock = (CtBlock<?>) returnedStatements[0];
                    oldBlock.getStatements().forEach(statementLists[0]::addStatement);

                    CtBlock<?> newBlock = (CtBlock<?>) returnedStatements[1];
                    newBlock.getStatements().forEach(statementLists[1]::addStatement);
                } else {
                    statementLists[0].addStatement(returnedStatements[0]);
                    statementLists[1].addStatement(returnedStatements[1]);
                }
            } else {
                statementLists[0].addStatement((CtStatement) element);
            }
        }
        return statementLists;
    }
}