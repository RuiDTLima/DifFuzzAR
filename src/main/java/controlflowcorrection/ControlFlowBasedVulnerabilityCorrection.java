package controlflowcorrection;

import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.ModifyStatementsFunction;
import util.NamingConvention;
import util.TraverseStatementsFunction;
import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
	private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
	private static final TreeMap<String, Pair<CtTypeReference<?>, CtExpression<?>>> VARIABLES_TO_ADD = new TreeMap<>();
	private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();
	private static HashMap<Class<?>, TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>, CtBlock<?>[]>> traverseStatements;
	private static HashMap<Class<?>, ModifyStatementsFunction<CtElement, Factory, CtIfImpl, Set<String>, List<CtVariable<?>>, CtStatement[]>> modifyStatements;

	/**
	 * The method used to add a new variable to the list of variables to add in the beginning of the method.
	 * @param name	The name of the variable to add.
	 * @param type	The type of the variable to add.
	 * @param defaultExpression	The value originally assigned to the variable.
	 */
	public static void addToVariablesToAdd(String name, CtTypeReference<?> type, CtExpression<?> defaultExpression) {
		Pair<CtTypeReference<?>, CtExpression<?>> value = new ImmutablePair<>(type, defaultExpression);
		VARIABLES_TO_ADD.put(name, value);
	}

	/**
	 * The method used to add a new pair of variables replacements.
	 * @param originalVariableName	The name of the variable being replaced.
	 * @param newVariableName	The name of the variable replacing the original one.
	 */
	public static void addToVariablesReplacement(String originalVariableName, String newVariableName) {
		VARIABLES_REPLACEMENT.put(originalVariableName, newVariableName);
	}

	/**
	 * The method to check if the variable with the given name has already been replaced.
	 * @param originalVariableName	The name of the original variable to be replaced.
	 * @return	True if the variable is being replaced, false otherwise.
	 */
	public static boolean isKeyInVariablesReplacement(String originalVariableName) {
		return VARIABLES_REPLACEMENT.containsKey(originalVariableName);
	}

	/**
	 * The method to get the name of the variable that is replacing the variable with the given name.
	 * @param originalVariableName	The name of the variable being replaced.
	 * @return	The name of the variable replacing the variable with the given name.
	 */
	public static String getValueVariablesReplacement(String originalVariableName) {
		return VARIABLES_REPLACEMENT.get(originalVariableName);
	}

	/**
	 * The method that fills the map that indicates, given the type of instructions, the method that knows how to traverse
	 * that instruction.
	 */
	private static void populateTraverseStatements() {
		traverseStatements = new HashMap<>();
		traverseStatements.put(CtIfImpl.class,            CtIfModification::traverseStatement);
		traverseStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::traverseStatement);
		traverseStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::traverseStatement);
		traverseStatements.put(CtTryImpl.class,           CtTryModification::traverseStatement);
		traverseStatements.put(CtForImpl.class,           CtForModification::traverseStatement);
		traverseStatements.put(CtLoopImpl.class,          CtLoopModification::traverseStatement);
	}

	/**
	 * The method that fills the map that indicates, given the type of instruction, the method that know how to modify
	 * that instruction.
	 */
	private static void populateModifyStatements() {
		modifyStatements = new HashMap<>();
		modifyStatements.put(CtAssignmentImpl.class,    CtAssignmentModification::modifyAssignment);
		modifyStatements.put(CtLocalVariableImpl.class, CtLocalVariableModification::modifyLocalVariable);
		modifyStatements.put(CtWhileImpl.class,         CtWhileModification::modifyWhile);
		modifyStatements.put(CtIfImpl.class,            CtIfModification::modifyIf);
		modifyStatements.put(CtUnaryOperatorImpl.class, CtUnaryOperatorModification::modifyUnaryOperator);
		modifyStatements.put(CtInvocationImpl.class,    CtInvocationModification::modifyInvocation);
	}

	/**
	 * The method that starts the correction of a <b>Control-Flow based timing side-channel</b>. It begins by finding
	 * the secret and public arguments, and then traverses the body of the method in the end produces a new method with
	 * the changes produced.
	 * @param factory	The factory used to create new instructions
	 * @param modifiedMethod	The method being modified.
	 * @param vulnerableMethodUsesCases	An object that indicates the name of the vulnerable method, the class and package
	 *                                  it belongs to, and the its arguments.
	 */
	public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod,
											VulnerableMethodUses vulnerableMethodUsesCases) {
		// TODO add validation of control-flow based timing side-channel vulnerability
		logger.info("The method suffers from control-flow based timing side-channel vulnerability.");
		populateTraverseStatements();
		populateModifyStatements();
		List<CtVariable<?>> secretVariables = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
		for (CtVariable<?> secretArgument : secretVariables) {
			logger.info("{} is a secret argument.", secretArgument.getSimpleName());
		}

		List<CtParameter<?>> publicArguments = findPublicArguments(modifiedMethod, vulnerableMethodUsesCases);

		CtBlock<?> methodBody = modifiedMethod.getBody();
		CtBlock<?>[] newMethodBodies = traverseMethodBody(factory, methodBody, secretVariables, publicArguments);

		CtBlock<?> newMethodBody = newMethodBodies[0];
		newMethodBody.setFactory(methodBody.getFactory());

		NamingConvention.resetCounter();
		addNewVariables(factory, newMethodBody);
		VARIABLES_TO_ADD.clear();
		VARIABLES_REPLACEMENT.clear();
		modifiedMethod.setBody(newMethodBody);
	}

	/**
	 * The method used to discover the secret arguments of the vulnerable method.
	 * @param modifiedMethod	The vulnerable method.
	 * @param vulnerableMethodUsesCases	An object that contains the arguments found during the analysis of the Driver.
	 * @return	Returns a list containing the secret arguments of the vulnerable method.
	 */
	private static List<CtVariable<?>> findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
		logger.info("Searching for the secret arguments.");
		ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
		String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
		String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

		for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
			String firstUseCaseArgumentsName = firstUseCaseArgumentsNames[idx];
			if (!firstUseCaseArgumentsName.equals(secondUseCaseArgumentsNames[idx])) {
				logger.info("The argument in position {} is a secret.", idx);
				secretArgumentsIndex.add(idx);
			}
		}

		List<CtParameter<?>> parameters = modifiedMethod.getParameters();
		List<CtVariable<?>> secretArguments = new ArrayList<>(secretArgumentsIndex.size());

		for (Integer argumentsIndex : secretArgumentsIndex) {
			secretArguments.add(parameters.get(argumentsIndex));
		}
		return secretArguments;
	}

	/**
	 * The method used to discover the public arguments of the vulnerable method. Meaning the arguments that don't contain
	 * a secret.
	 * @param modifiedMethod	The vulnerable method
	 * @param vulnerableMethodUsesCases	An object that contains the arguments found during the analysis of the Driver.
	 * @return	Returns a list containing the public arguments of the vulnerable method.
	 */
	private static List<CtParameter<?>> findPublicArguments(CtMethod<?> modifiedMethod,
															VulnerableMethodUses vulnerableMethodUsesCases) {
		logger.info("Searching for the public arguments.");
		ArrayList<Integer> publicArgumentsIndex = new ArrayList<>();
		String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
		String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

		for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
			if (firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
				logger.info("The argument in position {} is public.", idx);
				publicArgumentsIndex.add(idx);
			}
		}

		List<CtParameter<?>> parameters = modifiedMethod.getParameters();
		List<CtParameter<?>> publicArguments = new ArrayList<>(publicArgumentsIndex.size());

		for (Integer argumentsIndex : publicArgumentsIndex) {
			publicArguments.add(parameters.get(argumentsIndex));
		}
		return publicArguments;
	}

	/**
	 * The method used to traverse trough a block of statements, i.e. the body of a method, and then invoke specific methods
	 * that know how to traverse trough specific types os statements.
	 * @param factory	The factory used to create new instructions.
	 * @param blockStatements	The block of statements to be traversed.
	 * @param secretVariables	A list of secret variables.
	 * @param publicArguments	The list of public arguments.
	 * @return	Returns an array of blocks where in the first index is the original statement with slight modifications
	 * and in the second index is a completely changed statement.
	 */
	static CtBlock<?>[] traverseMethodBody(Factory factory, CtBlock<?> blockStatements, List<CtVariable<?>> secretVariables,
										   List<CtParameter<?>> publicArguments) {
		logger.info("Starting to traverse a block of statements.");
		CtBlock<?>[] statementLists = new CtBlock[2];

		CtBlock<?> oldStatementsList = new CtBlockImpl<>();
		CtBlock<?> newStatementsList = new CtBlockImpl<>();

		statementLists[0] = oldStatementsList;
		statementLists[1] = newStatementsList;

		for (CtStatement statement : blockStatements) {
			TraverseStatementsFunction<CtStatement, Factory, List<CtVariable<?>>, List<CtParameter<?>>, CtBlock<?>[]> function = traverseStatements.get(statement.getClass());
			if (function != null) {
				CtBlock<?>[] returnedStatements = function.apply(statement, factory, secretVariables, publicArguments);

				CtBlock<?> oldBlock = returnedStatements[0];
				oldBlock.getStatements().forEach(element -> statementLists[0].addStatement(element.clone()));

				CtBlock<?> newBlock = returnedStatements[1];
				newBlock.getStatements().forEach(element -> statementLists[1].addStatement(element.clone()));
			} else {
				statementLists[0].addStatement(statement.clone());
			}
		}
		return statementLists;
	}

	/**
	 * A method where variables create to replace existing ones are added to the method, usually in the beginning or if
	 * they are assigned a value that depends on another variable, after that variable is created.
	 * @param factory    The factory used to create new instructions
	 * @param newMethodBody    The body of the method where the variable will be added.
	 */
	private static void addNewVariables(Factory factory, CtBlock<?> newMethodBody) {
		logger.info("Adding the new variables to the method.");
		List<CtLocalVariable<?>> variableList = newMethodBody.getElements(new TypeFilter<>(CtLocalVariable.class));

		VARIABLES_TO_ADD.forEach((name, value) -> {
			CtTypeReference type = value.getLeft();
			CtExpression<?> defaultExpression = value.getRight();
			CtLocalVariable<?> newVariable;
			boolean created = false;
			if (defaultExpression == null) {
				CtExpression<?> assignment;
				String replacementKey = VARIABLES_REPLACEMENT.getKey(name);
				Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
						.filter(variable -> variable.getSimpleName().equals(replacementKey))
						.findFirst();
				if (replacedVariable.isPresent()) {
					CtLocalVariable<?> localVariable = replacedVariable.get();
					assignment = localVariable.getDefaultExpression();
				} else {
					assignment = null;
				}
				newVariable = factory.createLocalVariable(type, name, assignment);
			} else {
				newVariable = factory.createLocalVariable(type, name, defaultExpression);
				if (defaultExpression instanceof CtConstructorCall) {
					created = handleVariableCreation(variableList, (CtConstructorCall<?>) defaultExpression, newVariable);
				} else if (defaultExpression instanceof CtVariableReadImpl) {
					String variableRead = ((CtVariableReadImpl<?>) defaultExpression).getVariable().getSimpleName();
					created = createVariable(variableList, newVariable, variableRead);
				} else if (defaultExpression instanceof CtVariableWrite) {
					String variableRead = ((CtVariableWriteImpl<?>) defaultExpression).getVariable().getSimpleName();
					created = createVariable(variableList, newVariable, variableRead);
				}
			}

			if (!created) {
				newMethodBody.addStatement(0, newVariable);
			}
		});
	}

	/**
	 * The method to create the new variable taking in consideration the latest creation of one of the arguments.
	 * @param variableList	The list of variables in the method body.
	 * @param constructorCall	The constructor call to have its arguments checked.
	 * @param newVariable	The new variable being added.
	 * @return	Returns true if the variable was added to the method body, false otherwise.
	 */
	private static boolean handleVariableCreation(List<CtLocalVariable<?>> variableList, CtConstructorCall<?> constructorCall,
												  CtLocalVariable<?> newVariable) {
		boolean created;
		List<CtExpression<?>> arguments = constructorCall.getArguments();
		CtLocalVariable<?> lastVariable = null;
		int lastLine = 0;
		for (CtExpression<?> argument : arguments) {
			Optional<CtLocalVariable<?>> usedVariable = variableList.stream()
					.filter(variable -> variable.getSimpleName().equals(argument.toString()))
					.findFirst();

			if (usedVariable.isPresent()) {
				CtLocalVariable<?> localVariable = usedVariable.get();
				int line = localVariable.getPosition().getLine();
				if (line > lastLine) {
					lastVariable = localVariable;
					lastLine = line;
				}
			}
		}
		if (lastVariable != null) {
			lastVariable.insertAfter(newVariable);
			created = true;
		} else {
			created = false;
		}
		return created;
	}

	/**
	 * Method used to insert the new variable in the vulnerable method if it uses an argument that is variable that exists
	 * later in the method.
	 * @param variableList	The list of existing variable in the vulnerable method.
	 * @param newVariable	The new variable being created.
	 * @param argument	The argument being searched.
	 * @return	True if the variable was added to the method, false otherwise.
	 */
	private static boolean createVariable(List<CtLocalVariable<?>> variableList, CtLocalVariable<?> newVariable,
										  String argument) {
		boolean created = false;
		Optional<CtLocalVariable<?>> usedVariable = variableList.stream()
				.filter(variable -> variable.getSimpleName().equals(argument))
				.findFirst();

		if (usedVariable.isPresent()) {
			CtLocalVariable<?> localVariable = usedVariable.get();
			localVariable.insertAfter(newVariable);
			created = true;
		}
		return created;
	}

	/**
	 * The method to check if the statement uses a secret in any part.
	 * @param statement	The statement under analysis.
	 * @param secretVariables	A list of secret variables.
	 * @return	True if the statement uses any secret, false otherwise.
	 */
	static boolean usesSecret(String statement, List<CtVariable<?>> secretVariables) {
		for (CtVariable<?> secretVariable : secretVariables) {
			if (Arrays.stream(statement.split("\\."))
					.anyMatch(word -> word.matches(".*\\b" + secretVariable.getSimpleName() + "\\b.*"))) {
				return true;
			}
		}
		return false;
	}

	// index 0 -> sameElement; index 1 -> newElement.

	/**
	 * The method where the statements are modified according to their type. Each statement is modified and added to an
	 * array of lists of statements where in the first index is the same statement and in the second index is a modified
	 * version of the statement.
	 * @param factory	The factory used to create new instructions.
	 * @param statements	The statements to be modified.
	 * @param initialStatement	The initial 'if' statement that started this modification.
	 * @param dependableVariables	A set containing the dependable variables.
	 * @param secretVariables	A list of secret variables.
	 * @return	Returns an array of lists of statements where in the first index all the original statements with slight
	 * modifications and in the second index is the modified versions of the statements.
	 */
	static CtStatementList[] modifyStatements(Factory factory, List<CtStatement> statements, CtIfImpl initialStatement,
											  Set<String> dependableVariables,
											  List<CtVariable<?>> secretVariables) {
		CtStatementList[] statementLists = new CtStatementList[2];

		CtStatementList oldStatementsList = new CtStatementListImpl<>();
		CtStatementList newStatementsList = new CtStatementListImpl<>();

		statementLists[0] = oldStatementsList;
		statementLists[1] = newStatementsList;
		for (CtElement element : statements) {
			ModifyStatementsFunction<CtElement, Factory, CtIfImpl, Set<String>, List<CtVariable<?>>, CtStatement[]> function = modifyStatements.get(element.getClass());

			if (function != null) {
				CtStatement[] returnedStatements = function.apply(element, factory, initialStatement, dependableVariables, secretVariables);

				if (returnedStatements == null) {
					statementLists[0].addStatement(null);
				} else if (returnedStatements[0] instanceof CtBlock) {
					CtBlock<?> oldBlock = (CtBlock<?>) returnedStatements[0];
					oldBlock.getStatements().forEach(statementLists[0]::addStatement);

					CtBlock<?> newBlock = (CtBlock<?>) returnedStatements[1];
					newBlock.getStatements().forEach(statementLists[1]::addStatement);
				} else {
					statementLists[0].addStatement(returnedStatements[0]);
					statementLists[1].addStatement(returnedStatements[1]);
				}
			} else {
				statementLists[0].addStatement((CtStatement) element);
			}
		}
		return statementLists;
	}
}