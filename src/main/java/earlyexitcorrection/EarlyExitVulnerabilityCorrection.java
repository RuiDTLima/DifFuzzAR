package earlyexitcorrection;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.ReturnOrThrowFilter;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.*;
import util.EarlyExitFunction;
import util.NamingConvention;
import java.util.*;
import java.util.stream.Stream;

public class EarlyExitVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(EarlyExitVulnerabilityCorrection.class);
    private static final ArrayList<String> VARIABLES_NULL_CHECKED = new ArrayList<>();
    private static final HashMap<String, List<CtExpression<Boolean>>> PROTECTED_VARIABLES = new HashMap<>();
    private static final HashMap<Class<?>, EarlyExitFunction<Factory, Iterator<CtCFlowBreak>, CtLocalVariable<?>, CtExpression<?>, Boolean, CtBlock<?>, CtStatement, Boolean>> earlyExitFunctions = new HashMap<>();

    //region Helper methods
    /**
     * Adds the received variable to the list of variables that are compared to null.
     * @param variable  The variable to add to the list.
     */
    static void addVariableNullChecked(String variable) {
        VARIABLES_NULL_CHECKED.add(variable);
    }

    /**
     * Checks if the variable received is the list of protected variables.
     * @param variable  The variable to check if it is in the list.
     * @return  True if the variable is in the list, false otherwise.
     */
    static boolean isKeyInProtectedVariables(String variable) {
        return PROTECTED_VARIABLES.containsKey(variable);
    }

    /**
     * Obtains the list of protection expressions of 'variable.
     * @param variable  The variable to obtain the list of protections expressions from.
     * @return  The list of protections expressions.
     */
    static List<CtExpression<Boolean>> getProtectionOfVariable(String variable) {
        return PROTECTED_VARIABLES.get(variable);
    }

    /**
     * Obtains the list of protection expression if the variable is already being protected or creates an empty list
     * otherwise.
     * @param variable  The variable to obtain the list of protections expressions.
     * @return  The current list of protections expressions.
     */
    static List<CtExpression<Boolean>> getProtectionOfVariableOrEmpty(String variable) {
        if (PROTECTED_VARIABLES.containsKey(variable)) {
            return PROTECTED_VARIABLES.get(variable);
        }
        return new ArrayList<>();
    }

    /**
     * Adds a new list of protection expressions of 'variable'.
     * @param variable  The variable to add its list of protection expressions.
     * @param conditions    The list of protection expressions.
     */
    static void addVariableProtection(String variable, List<CtExpression<Boolean>> conditions) {
        PROTECTED_VARIABLES.put(variable, conditions);
    }

    /**
     * Adds all the class and the corresponding methods that can protect.
     */
    private static void populateEarlyExitFunctions() {
        earlyExitFunctions.put(CtIfImpl.class,            CtIfHandle::handleIf);
        earlyExitFunctions.put(CtWhileImpl.class,         CtWhileHandle::handleWhile);
        earlyExitFunctions.put(CtForImpl.class,           CtForHandle::handleFor);
        earlyExitFunctions.put(CtReturnImpl.class,        CtReturnHandle::handleReturn);
        earlyExitFunctions.put(CtLocalVariableImpl.class, CtLocalVariableHandle::handleLocalVariable);
    }
    //endregion

    /**
     * The main method to correct the early-exit timing side-channel vulnerabilities on the vulnerable method
     * @param factory   The factory used to create new instructions.
     * @param vulnerableMethod  The vulnerable method to be modified.
     */
    public static void correctVulnerability(Factory factory, CtMethod<?> vulnerableMethod) {
        populateEarlyExitFunctions();
        NamingConvention.resetCounter();
        List<CtCFlowBreak> returnList = vulnerableMethod.getElements(new ReturnOrThrowFilter());
        returnList.removeIf(returnOrThrow -> !(returnOrThrow instanceof CtReturnImpl));

        int numberOfReturns = returnList.size();
        if (numberOfReturns <= 1) {
            return;
        }

        logger.info("The method suffers from early-exit timing side-channel vulnerability since it has {} exit points.",
                numberOfReturns);

        List<CtLocalVariable<?>> variableList = vulnerableMethod.getElements(new TypeFilter<>(CtLocalVariable.class));
        CtBlock<?> modifiedMethodBody = vulnerableMethod.getBody();

        int lastIndex = numberOfReturns - 1;
        CtReturnImpl<?> finalReturnElement = (CtReturnImpl<?>) returnList.get(lastIndex);
        CtExpression<?> returnedExpression = finalReturnElement.getReturnedExpression();

        Optional<CtLocalVariable<?>> optionalReturnAssignment = variableList.stream()
                .filter(it -> it.getReference().toString().matches(".*\\b" + returnedExpression + "\\b.*"))
                .findFirst();

        CtExpression<?> returnElement = findValueToReturn(variableList, returnedExpression, returnedExpression);

        CtLocalVariable<?> returnVariable = createReturnVariable(factory, vulnerableMethod.getType(), variableList, modifiedMethodBody,
                optionalReturnAssignment, returnElement);

        Iterator<CtCFlowBreak> returnsIterator = returnList.iterator();

        CtBlock<?> newMethodBody = handleStatements(factory, modifiedMethodBody.iterator(), returnsIterator, returnVariable, returnElement, false);

        List<CtCFlowBreak> newReturnList = newMethodBody.getElements(new ReturnOrThrowFilter());
        newReturnList.removeIf(returnOrThrow -> !(returnOrThrow instanceof CtReturnImpl));

        if (newReturnList.size() == 0) {
            modifyLastReturn(factory, newMethodBody, returnVariable);
        }

        List<CtLocalVariable<?>> newVariableList = newMethodBody.getElements(new TypeFilter<>(CtLocalVariable.class));

        if (!VARIABLES_NULL_CHECKED.isEmpty()) {
            protectVariableAccess(factory, newVariableList);
        }

        vulnerableMethod.setBody(newMethodBody);
    }

    /**
     * The method where each statement will be analysed and either the original statement or the modified version, if the
     * statement is modified will be added to the new block to replace the method.
     * @param factory   The factory used to create new instructions.
     * @param iterator  The iterator of the vulnerable method.
     * @param returnsIterator   An iterator over the returns of the method.
     * @param returnVariable    The variable to be returned.
     * @param returnElement The valid return expression returned in the final return statement. Can't be a binary operator
     *                      nor an invocation that uses a variable.
     * @param afterWhileReturn  Indicates if this 'for' statement happens after a 'while' statement.
     * @return  Returns the new block of statements to represent the corrected version of the vulnerable method.
     */
    static CtBlock<?> handleStatements(Factory factory,
                                               Iterator<CtStatement> iterator,
                                               Iterator<CtCFlowBreak> returnsIterator,
                                               CtLocalVariable<?> returnVariable,
                                               CtExpression<?> returnElement,
                                               boolean afterWhileReturn) {

        CtBlock<?> newBody = factory.createBlock();
        while (iterator.hasNext()) {
            CtStatement currentStatement = iterator.next();
            EarlyExitFunction<Factory, Iterator<CtCFlowBreak>, CtLocalVariable<?>, CtExpression<?>, Boolean, CtBlock<?>, CtStatement, Boolean> function = earlyExitFunctions.get(currentStatement.getClass());

            if (function != null) {
                afterWhileReturn = function.apply(factory, returnsIterator, returnVariable, returnElement, afterWhileReturn, newBody, currentStatement);
            } else {
                newBody.addStatement(currentStatement.clone());
                afterWhileReturn = false;
            }
        }
        return newBody;
    }

    /**
     * Determines if the final return, returns the result of a method invocation. If so, it is important to ensure that
     * all arguments passed to the method are available at the start of the method execution. Otherwise the created variable
     * will be declared without a starting value.
     * @param variableList the list of variables in the method.
     * @param returnedExpression the expression returned in the last return of the method.
     * @param finalReturn   The value returned in the last return of the method.
     * @return The value to initiate the new variable with.
     */
    private static CtExpression<?> findValueToReturn(List<CtLocalVariable<?>> variableList,
                                                     CtExpression<?> returnedExpression,
                                                     CtExpression<?> finalReturn) {
        CtExpression<?> returnElement;
        if (returnedExpression instanceof CtInvocation) {
            Stream<?> lastReturnInvocationArguments = ((CtInvocationImpl<?>) returnedExpression)
                    .getArguments()
                    .stream()
                    .flatMap(elem -> Arrays.stream(elem.toString().split("\\.")).limit(1));

            if (lastReturnInvocationArguments.noneMatch(argument -> variableList.stream().anyMatch(variable -> variable.getReference().getDeclaration().getSimpleName().equals(argument)))) {
                returnElement = finalReturn;
            } else
                returnElement = null;
        } else if (returnedExpression instanceof CtBinaryOperator)
            returnElement = null;
        else
            returnElement = finalReturn;
        return returnElement;
    }

    /**
     * Method where the variable used to contain the value to be returned in the end of the method is created. Or the existing
     * variable to be return is added to the beginning of the method to allow assignment anywhere in the method where a return
     * exists.
     * @param factory The factory used to create code snippets to add.
     * @param methodReturnType The return type of the method to modify.
     * @param variableList  The list of variables created inside the method
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param optionalReturnAssignment  If a value is present it means that a new variable to be returned needs to be created.
     * @param returnElement The element to return.
     * @return The variable to be returned, either an existing variable or the newly created one.
     */
    private static CtLocalVariable<?> createReturnVariable(Factory factory, CtTypeReference<?> methodReturnType,
                                                           List<CtLocalVariable<?>> variableList,
                                                           CtBlock<?> modifiedMethodBody,
                                                           Optional<CtLocalVariable<?>> optionalReturnAssignment,
                                                           CtExpression<?> returnElement) {

        CtLocalVariable<?> newVariable = null;

        if (!optionalReturnAssignment.isPresent()) {
            CtExpression<?> defaultExpression;
            if (returnElement == null) {
                defaultExpression = null;
            } else {
                CtElement returnParent = returnElement.getParent().getParent().getParent();
                if (returnParent instanceof CtIf) {
                    defaultExpression = null;
                } else {
                    defaultExpression = returnElement;
                }
            }

            newVariable = NamingConvention.produceNewVariable(factory, methodReturnType, defaultExpression);
            modifiedMethodBody.addStatement(0, newVariable);
            logger.info("Added the instruction {}.", newVariable);
        } else {
            CtLocalVariable<?> returnAssignmentToRemove = optionalReturnAssignment.get();
            CtLocalVariable<?> returnAssignmentToAdd = returnAssignmentToRemove.clone();

            if (returnAssignmentToRemove.getDefaultExpression() instanceof CtNewArrayImpl) {    // In response to themis_dynatable_unsafe
                List<CtExpression<Integer>> dimensionExpressions = ((CtNewArrayImpl<?>) returnAssignmentToRemove.getDefaultExpression())
                        .getDimensionExpressions();

                for (CtLocalVariable<?> variable : variableList) {
                    if (dimensionExpressions.stream().anyMatch(arraySize -> variable.getSimpleName().equals(arraySize.toString()))) {
                        String returnName = returnAssignmentToRemove.getSimpleName();
                        CtExpression assignment = returnAssignmentToRemove.getAssignment();
                        CtTypeReference<?> returnType = returnAssignmentToRemove.getType();

                        newVariable = factory.createLocalVariable(returnType, returnName, null);
                        CtAssignment<?, ?> variableAssignment = factory.createVariableAssignment(newVariable.getReference(), false, assignment);
                        returnAssignmentToRemove.replace(variableAssignment);
                        modifiedMethodBody.addStatement(0, newVariable);
                        break;
                    }
                }
            } else {
                modifiedMethodBody.removeStatement(returnAssignmentToRemove);
                modifiedMethodBody.addStatement(0, returnAssignmentToAdd);
                newVariable = returnAssignmentToAdd;
            }
        }
        return newVariable;
    }

    /**
     * Modifies the final return of the vulnerable method. This needs to be different because it will not only eliminate
     * a return expression but modified. If the last return was an expression and it wasn't already assigned to the return
     * variable it is now, and a new return expression is created.
     * @param factory   The factory used to create code snippets to add.
     * @param modifiedMethodBody    The body - a block of code - of the method modified. The new version of the method being modified
     * @param variable  The name of the variable to be returned.
     */
    private static void modifyLastReturn(Factory factory, CtBlock<?> modifiedMethodBody,
                                                CtLocalVariable<?> variable){
        CtReturn<?> objectCtReturn = factory.createReturn().setReturnedExpression(factory.createCodeSnippetExpression(variable.getSimpleName()));

        modifiedMethodBody.addStatement(objectCtReturn);
    }

    /**
     * The method where a field read that was compared to null will be protected by adding a null check before accessing
     * it. The variable assignment will become the 'then' block of an 'if' statement that checks that variable for null.
     * A new local variable of that variable will be added before that 'if' statement to guarantee that the variable
     * exists.
     * @param factory   The factory used to create new instructions.
     * @param variableList  The list of variables of the method.
     */
    private static void protectVariableAccess(Factory factory, List<CtLocalVariable<?>> variableList) {
        variableList.stream()
                .filter(variable -> {
                    CtExpression<?> assignment = variable.getAssignment();
                    if (assignment instanceof CtFieldReadImpl) {
                        String target = ((CtFieldReadImpl<?>) assignment).getTarget().toString();
                        return VARIABLES_NULL_CHECKED.contains(target);
                    }
                    return false;
                }).forEach(variable -> {
                    CtFieldReadImpl assignment = (CtFieldReadImpl<?>) variable.getAssignment();
                    CtBinaryOperator<Boolean> checkNull = addNullCheck(factory, assignment.getTarget());
                    CtIf anIf = factory.createIf();
                    CtBlock<?> thenBlock = factory.createBlock();
                    anIf.setCondition(checkNull);

                    CtAssignment thenStatement = factory.createVariableAssignment(variable.getReference(), false, assignment);
                    thenStatement.setType(variable.getType());
                    thenBlock.addStatement(thenStatement);
                    anIf.setThenStatement(thenBlock);

                    String variableName = variable.getSimpleName();
                    CtTypeReference variableType = variable.getType();
                    CtExpression<?> defaultValue = null;
                    if (variableType.isPrimitive()) {
                        if (variableType.getSimpleName().equals("String")) {
                            defaultValue = factory.createLiteral("");
                        } else if (variableType.getSimpleName().equals("boolean")) {
                            defaultValue = factory.createLiteral(false);
                        } else
                            defaultValue = factory.createLiteral(0);
                    }

                    CtLocalVariable<?> localVariable = factory.createLocalVariable(variableType, variableName, defaultValue);

                    // Needs to follow this order to ensure that the declaration of the variable comes first
                    variable.insertAfter(anIf);
                    variable.replace(localVariable);
                });
    }

    /**
     * The method that produces a new binary operator responsible for creating a null check of the variable.
     * @param factory   The factory used to create new instructions.
     * @param variable  The variable to be check for null.
     * @return  Returns a new binary operator that checks if the variable is not null.
     */
    static CtBinaryOperator<Boolean> addNullCheck(Factory factory, CtExpression<?> variable) {
        CtBinaryOperator<Boolean> newCondition = null;
        if (VARIABLES_NULL_CHECKED.contains(variable.toString())) {
            newCondition = factory.createBinaryOperator(variable, factory.createLiteral(null), BinaryOperatorKind.NE);
        }
        return newCondition;
    }
}