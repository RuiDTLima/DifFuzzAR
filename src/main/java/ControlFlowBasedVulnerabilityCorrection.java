import model.VulnerableMethodUses;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtNamedElement;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.CtAssignmentImpl;
import spoon.support.reflect.code.CtBlockImpl;
import spoon.support.reflect.code.CtIfImpl;
import spoon.support.reflect.code.CtStatementListImpl;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final String VARIABLE_TO_ADD_NAME = "$";
    private static int counter = 1;
    private static CtTypeReference<?> variableType = null;
    private static boolean incremented = false;

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        String[] secretArguments = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (String secretArgument : secretArguments) {
            logger.info("{} is a secret argument.", secretArgument);
        }

        CtBlock<?> methodBody = modifiedMethod.getBody();
        traverseMethodBody(factory, methodBody, secretArguments);

        if (variableType != null && !incremented) {
            CtCodeSnippetStatement $1  = factory.createCodeSnippetStatement(variableType + " " + VARIABLE_TO_ADD_NAME + counter);
            methodBody.addStatement(0, $1);
        }
        // TODO alter this to avoid resetting the fields for the test.
        variableType = null;
        counter = 1;
        incremented = false;
    }

    private static String[] findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (!firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();

        String[] secretArguments = new String[secretArgumentsIndex.size()];

        for (int idx = 0; idx < secretArgumentsIndex.size(); idx++) {
            secretArguments[idx] = parameters.get(secretArgumentsIndex.get(idx)).getSimpleName();
        }
        return secretArguments;
    }

    private static void traverseMethodBody(Factory factory, CtBlock<?> methodBody, String[] secretArguments) {
        List<CtLocalVariable<?>> variableList = methodBody.getElements(new TypeFilter<>(CtLocalVariable.class));
        for (CtStatement statement : methodBody) {
            if (statement instanceof CtIfImpl && usesSecret((CtIfImpl) statement, secretArguments)) {
                logger.info("Found the source of vulnerability.");
                handleVulnerability(factory, variableList, (CtIfImpl) statement);
            }
            if (statement instanceof CtLoop) {
                CtLoop ctLoop = (CtLoop) statement;
                traverseMethodBody(factory, ((CtBlock<?>)ctLoop.getBody()), secretArguments);
            }
        }
    }

    private static boolean usesSecret(CtIfImpl statement, String[] secretArguments) {
        for (String secretArgument : secretArguments) {
            if (Arrays.stream(statement.getCondition().toString().split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + secretArgument + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    private static void handleVulnerability(Factory factory, List<CtLocalVariable<?>> variableList, CtIfImpl statement) {
        CtBlock<?> thenStatement = (CtBlock<?>) statement.getThenStatement().clone();
        CtBlock<?> elseStatement = statement.getElseStatement();
        if (elseStatement == null) {
            CtBlock<Object> block = factory.createBlock();
            elseStatement = block.insertBegin(modifyStatements(factory, variableList, thenStatement.getStatements()));
        } else {
            List<CtStatement> thenStatements = thenStatement.getStatements();
            List<CtStatement> elseStatements = elseStatement.getStatements();
            CtStatementList thenStatementsList = modifyStatements(factory, variableList, thenStatements);
            CtStatementList elseStatementsList = modifyStatements(factory, variableList, elseStatements);
            thenStatement.insertEnd(elseStatementsList);
            elseStatement.insertEnd(thenStatementsList);
            statement.setThenStatement(thenStatement);
        }
        statement.setElseStatement(elseStatement);
    }

    private static CtStatementList modifyStatements(Factory factory, List<CtLocalVariable<?>> variableList, List<CtStatement> statements) {
        CtStatementList statementList = new CtStatementListImpl<>();
        for (CtElement element : statements) {
            CtExpression<?> variableExpression = factory.createCodeSnippetExpression(VARIABLE_TO_ADD_NAME + counter);
            if (element instanceof CtAssignmentImpl) {
                CtAssignmentImpl<?, ?> assignment = (CtAssignmentImpl<?, ?>) element;
                if (variableType != assignment.getType()) {
                    variableType = assignment.getType();
                }
                logger.info("Found an assignment");
                CtStatement blockStatement = factory.createCodeSnippetStatement(VARIABLE_TO_ADD_NAME + counter + " = " + (assignment.getAssignment().clone()));      // Needs the clone to avoid an error claiming to be replacing the node of the model.
                statementList.addStatement(blockStatement);
            } else if (element instanceof CtLocalVariable) {
                counter++;
                incremented = true;
                CtNamedElement ctNamedElement = ((CtLocalVariable<?>) element.clone()).setSimpleName(VARIABLE_TO_ADD_NAME + counter);
                statementList.addStatement((CtStatement) ctNamedElement);
            } else if (element instanceof CtWhile) {
                CtWhile whileStatement = ((CtWhile) element.clone());
                CtBinaryOperator<Boolean> loopingExpression = (CtBinaryOperator<Boolean>) whileStatement.getLoopingExpression();
                if (variableList.stream()
                        .anyMatch(variable -> variable.getReference().getDeclaration().getSimpleName()
                                .equals(loopingExpression.getLeftHandOperand().toString()))) {

                    loopingExpression.setLeftHandOperand(variableExpression);
                }
                if (variableList.stream()
                        .anyMatch(variable -> variable.getReference().getDeclaration().getSimpleName()
                                .equals(loopingExpression.getRightHandOperand().toString()))) {

                    loopingExpression.setRightHandOperand(variableExpression);
                }
                List<CtStatement> bodyStatements = ((CtBlock<?>) whileStatement.getBody()).getStatements();
                CtStatementList bodyNewStatements = modifyStatements(factory, variableList, bodyStatements);
                CtBlockImpl<?> ctBlock = new CtBlockImpl<>();
                bodyNewStatements.forEach(ctStatement -> ctBlock.addStatement(ctStatement.clone()));    // Needs clone to avoid error by modify node parent.
                whileStatement.setBody(ctBlock);
                statementList.addStatement(whileStatement);
            } else if (element instanceof CtUnaryOperator) {
                CtUnaryOperator<?> ctUnaryOperator = ((CtUnaryOperator) element).setOperand(variableExpression);
                statementList.addStatement(ctUnaryOperator);
            }
        }
        return statementList;
    }
}