import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.CtAssignmentImpl;
import spoon.support.reflect.code.CtBlockImpl;
import spoon.support.reflect.code.CtIfImpl;
import spoon.support.reflect.code.CtStatementListImpl;
import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final String NAME_FOR_VARIABLE = "$";
    private static final TreeMap<String, String> VARIABLES_TO_ADD = new TreeMap<>();
    private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();
    private static int counter = 0;

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        List<CtParameter<?>> secretArguments = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (CtParameter<?> secretArgument : secretArguments) {
            logger.info("{} is a secret argument.", secretArgument.getSimpleName());
        }

        List<CtParameter<?>> publicArguments = findPublicArguments(modifiedMethod, vulnerableMethodUsesCases);

        CtBlock<?> methodBody = modifiedMethod.getBody();
        traverseMethodBody(factory, methodBody, secretArguments, publicArguments);

        List<CtLocalVariable<?>> variableList = methodBody.getElements(new TypeFilter<>(CtLocalVariable.class));
        counter = 0;
        // TODO is it worth to order the list just so that variables appear ordered?
        VARIABLES_TO_ADD.descendingMap().forEach((name, type) -> {
            String key = VARIABLES_REPLACEMENT.getKey(name);
            Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
                    .filter(variable -> variable.getSimpleName().equals(key))
                    .findFirst();
            CtCodeSnippetStatement newVariable;
            if (replacedVariable.isPresent()) {
                CtLocalVariable<?> localVariable = replacedVariable.get();
                CtExpression<?> assignment = localVariable.getDefaultExpression();
                if (assignment == null) {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name);
                } else {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name + " = " + assignment);
                }
            } else {
                newVariable = factory.createCodeSnippetStatement(type + " " + name);
            }
            methodBody.addStatement(0, newVariable);
        });
        // TODO remove clear
        VARIABLES_TO_ADD.clear();
        VARIABLES_REPLACEMENT.clear();
    }

    private static List<CtParameter<?>> findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            String firstUseCaseArgumentsName = firstUseCaseArgumentsNames[idx];
            if (!firstUseCaseArgumentsName.equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtParameter<?>> secretArguments = new ArrayList<>(secretArgumentsIndex.size());

        for (Integer argumentsIndex : secretArgumentsIndex) {
            secretArguments.add(parameters.get(argumentsIndex));
        }
        return secretArguments;
    }

    private static List<CtParameter<?>> findPublicArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> publicArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is public.", idx);
                publicArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();
        List<CtParameter<?>> publicArguments = new ArrayList<>(publicArgumentsIndex.size());

        for (Integer argumentsIndex : publicArgumentsIndex) {
            publicArguments.add(parameters.get(argumentsIndex));
        }
        return publicArguments;
    }

    private static void traverseMethodBody(Factory factory, CtBlock<?> methodBody, List<CtParameter<?>> secretArguments, List<CtParameter<?>> publicArguments) {
        for (CtStatement statement : methodBody) {
            if (statement instanceof CtIfImpl) {
                CtIfImpl ifStatement = (CtIfImpl) statement;
                if (usesSecret(ifStatement.getCondition().toString(), secretArguments)) {
                    logger.info("Found the source of vulnerability.");
                    handleVulnerability(factory, ifStatement);
                } else {
                    CtBlock<?> thenBlock = ifStatement.getThenStatement();
                    CtBlock<?> elseBlock = ifStatement.getElseStatement();
                    traverseMethodBody(factory, thenBlock, secretArguments, publicArguments);
                    if (elseBlock != null)
                        traverseMethodBody(factory, elseBlock, secretArguments, publicArguments);
                }
            }
            if (statement instanceof CtLoop) {
                if (statement instanceof CtFor) {
                    CtFor ctFor = (CtFor) statement;
                    CtExpression<Boolean> forExpression = ctFor.getExpression();

                    if (usesSecret(forExpression.toString(), secretArguments)) {
                        logger.info("Cycle stopping condition depends on the secret.");
                        if (forExpression instanceof CtBinaryOperator) {
                            CtBinaryOperator<Boolean> binaryOperator = (CtBinaryOperator<Boolean>) forExpression;
                            CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
                            CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();
                            String leftHandOperandString = leftHandOperand.toString();
                            String rightHandOperandString = rightHandOperand.toString();
                            for (CtParameter<?> secretArgument : secretArguments) {
                                String secretArgumentSimpleName = secretArgument.getSimpleName();
                                if (Arrays.stream(leftHandOperandString.split("\\."))
                                        .anyMatch(word -> word.matches(".*\\b" + secretArgumentSimpleName + "\\b.*"))) {

                                    Optional<CtParameter<?>> optionalPublicArgument = publicArguments.stream()
                                            .filter(publicArgument -> publicArgument.getType().equals(secretArgument.getType()))
                                            .findFirst();

                                    String newLeftHandOperand;
                                    if (optionalPublicArgument.isPresent()) {
                                        String publicArgumentSimpleName = optionalPublicArgument.get().getSimpleName();
                                        newLeftHandOperand = leftHandOperandString.replace(secretArgumentSimpleName, publicArgumentSimpleName);
                                        leftHandOperand = factory.createCodeSnippetExpression(newLeftHandOperand);
                                    }

                                } else if (Arrays.stream(rightHandOperandString.split("\\."))
                                        .anyMatch(word -> word.matches(".*\\b" + secretArgumentSimpleName + "\\b.*"))) {

                                    Optional<CtParameter<?>> optionalPublicArgument = publicArguments.stream()
                                            .filter(publicArgument -> publicArgument.getType().equals(secretArgument.getType()))
                                            .findFirst();

                                    String newRightHandOperand;
                                    if (optionalPublicArgument.isPresent()) {
                                        String publicArgumentSimpleName = optionalPublicArgument.get().getSimpleName();
                                        newRightHandOperand = rightHandOperandString.replace(secretArgumentSimpleName, publicArgumentSimpleName);
                                        rightHandOperand = factory.createCodeSnippetExpression(newRightHandOperand);
                                    }
                                }
                            }
                            binaryOperator.setLeftHandOperand(leftHandOperand);
                            binaryOperator.setRightHandOperand(rightHandOperand);
                            ctFor.setExpression(binaryOperator);
                        }
                    }
                    traverseMethodBody(factory, ((CtBlock<?>)ctFor.getBody()), secretArguments, publicArguments);

                } else {
                    CtLoop ctLoop = (CtLoop) statement;
                    traverseMethodBody(factory, ((CtBlock<?>) ctLoop.getBody()), secretArguments, publicArguments);
                }
            }
        }
    }

    private static boolean usesSecret(String ifCondition, List<CtParameter<?>> secretArguments) {
        for (CtParameter<?> secretArgument : secretArguments) {
            if (Arrays.stream(ifCondition.split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + secretArgument.getSimpleName() + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    private static void handleVulnerability(Factory factory, CtIfImpl statement) {
        CtBlock<?> thenStatement = statement.getThenStatement();
        CtBlock<?> elseStatement = statement.getElseStatement();

        List<CtStatement> thenStatements = thenStatement.clone().getStatements();
        CtStatementList thenStatementsList = modifyStatements(factory, thenStatements, statement);

        if (elseStatement == null) {
            CtBlock<Object> block = factory.createBlock();
            elseStatement = block.insertEnd(thenStatementsList);
        } else {
            List<CtStatement> elseStatements = elseStatement.clone().getStatements();   // TODO why clone?
            CtStatementList elseStatementsList = modifyStatements(factory, elseStatements, statement);
            thenStatement.insertEnd(elseStatementsList);
            elseStatement.insertEnd(thenStatementsList);
            statement.setThenStatement(thenStatement);
        }
        statement.setElseStatement(elseStatement);
    }

    private static CtStatementList modifyStatements(Factory factory, List<CtStatement> statements, CtIfImpl initialStatement) {
        CtStatementList statementList = new CtStatementListImpl<>();
        for (CtElement element : statements) {
            CtStatement statement = null;
            if (element instanceof CtAssignmentImpl) {
                logger.info("Element is an assignment.");
                statement = modifyAssignment(factory, (CtAssignmentImpl<?, ?>) element);
            } else if (element instanceof CtLocalVariable) {
                logger.info("Element is a local variable.");
                statement = (CtStatement) modifyLocalVariable((CtLocalVariable<?>) element);
            } else if (element instanceof CtWhile) {
                logger.info("Element is a while block.");
                statement = modifyWhile(factory, initialStatement, (CtWhile) element);
            } else if (element instanceof CtIf) {
                logger.info("Element is an if block.");
                CtIfImpl ifElement = (CtIfImpl) element;
                CtBlock<?> newElse = modifyIf(factory, initialStatement, ifElement);
                newElse.getStatements().forEach(statementList::addStatement);
            } else if (element instanceof CtUnaryOperator) {
                logger.info("Element is a unary operator.");
                CtUnaryOperator<?> unaryOperator = (CtUnaryOperator<?>) element;
                String operand = unaryOperator.getOperand().toString();
                if (VARIABLES_REPLACEMENT.containsKey(operand)) {
                    CtExpression variableExpression = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(operand));
                    statement =  unaryOperator.setOperand(variableExpression);
                } else {
                    statement = null;
                }
            }
            statementList.addStatement(statement);
        }
        return statementList;
    }

    private static CtStatement modifyAssignment(Factory factory, CtAssignmentImpl<?, ?> assignmentImpl) {
        logger.info("Found an assignment.");
        CtExpression<?> assigned = assignmentImpl.getAssigned();
        CtExpression<?> assignment = assignmentImpl.getAssignment();
        String newAssigned;
        String newAssignment = assignment.toString();
        if (VARIABLES_REPLACEMENT.containsKey(assigned.toString())) {
            newAssigned = VARIABLES_REPLACEMENT.get(assigned.toString());
        } else {
            String type = assignmentImpl.getType().getSimpleName();
            counter++;
            newAssigned = NAME_FOR_VARIABLE + counter;
            VARIABLES_REPLACEMENT.put(assigned.toString(), newAssigned);
            VARIABLES_TO_ADD.put(newAssigned, type);
        }
        if (assignment instanceof CtArrayRead) {
            CtArrayRead<?> newArrayRead = modifyArrayOperation(factory, (CtArrayRead<?>) assignment);
            newAssignment = newArrayRead.toString();
        } else if (assignment instanceof CtBinaryOperator){
            newAssignment = modifyBinaryOperator(factory, (CtBinaryOperator<?>) assignment);
        }

        return factory.createCodeSnippetStatement(newAssigned + " = " + newAssignment);
    }

    private static CtArrayRead<?> modifyArrayOperation(Factory factory, CtArrayRead<?> arrayRead) {
        CtExpression<?> target = arrayRead.getTarget();
        CtExpression<Integer> indexExpression = arrayRead.getIndexExpression();
        CtArrayRead<?> newArrayRead = factory.createArrayRead();
        if (VARIABLES_REPLACEMENT.containsKey(target.toString())) {
            CtCodeSnippetExpression<?> newTarget = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(target.toString()));
            newArrayRead.setTarget(newTarget);
        } else {
            newArrayRead.setTarget(target);
        }
        if (VARIABLES_REPLACEMENT.containsKey(indexExpression.toString())) {
            CtCodeSnippetExpression<Integer> newIndex = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(indexExpression.toString()));
            newArrayRead.setIndexExpression(newIndex);
        }
        return newArrayRead;
    }

    private static String modifyBinaryOperator(Factory factory, CtBinaryOperator<?> binaryOperator) {
        CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
        CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();
        if (leftHandOperand instanceof CtVariableRead) {
            CtExpression<?> leftHandOperator = modifyVariableRead(factory, leftHandOperand);
            binaryOperator.setLeftHandOperand(leftHandOperator);
        } else if (leftHandOperand instanceof CtArrayRead) {
            CtArrayRead<?> leftOperand = modifyArrayOperation(factory, (CtArrayRead<?>) leftHandOperand);
            binaryOperator.setLeftHandOperand(leftOperand);
        }
        if (rightHandOperand instanceof CtVariableRead) {
            CtExpression<?> rightHandOperator = modifyVariableRead(factory, rightHandOperand);
            binaryOperator.setRightHandOperand(rightHandOperator);
        }
        return binaryOperator.toString();
    }

    private static CtExpression<?> modifyVariableRead(Factory factory, CtExpression<?> handOperand) {
        String leftHandOperator = handOperand.toString();
        CtExpression<?> newHandOperator;
        if (VARIABLES_REPLACEMENT.containsKey(leftHandOperator)) {
            String newLeftHandOperatorVariable = VARIABLES_REPLACEMENT.get(leftHandOperator);
            newHandOperator = factory.createCodeSnippetExpression(newLeftHandOperatorVariable);
        } else {
            String type = handOperand.getType().toString();
            counter++;
            newHandOperator = factory.createCodeSnippetExpression(NAME_FOR_VARIABLE + counter);
            VARIABLES_REPLACEMENT.put(leftHandOperator, newHandOperator.toString());
            VARIABLES_TO_ADD.put(newHandOperator.toString(), type);
        }
        return  newHandOperator;
    }

    private static CtNamedElement modifyLocalVariable(CtLocalVariable<?> localVariable) {
        counter++;
        String newVariable = NAME_FOR_VARIABLE + counter;
        VARIABLES_REPLACEMENT.put(localVariable.getSimpleName(), newVariable);
        return localVariable.setSimpleName(newVariable);
    }

    private static CtWhile modifyWhile(Factory factory, CtIfImpl initialStatement, CtWhile whileStatement) {
        CtBinaryOperator<Boolean> loopingExpression = (CtBinaryOperator<Boolean>) whileStatement.getLoopingExpression();
        String leftHandOperand = loopingExpression.getLeftHandOperand().toString();
        String rightHandOperand = loopingExpression.getRightHandOperand().toString();

        if (VARIABLES_REPLACEMENT.containsKey(leftHandOperand)) {
            String replacement = VARIABLES_REPLACEMENT.get(leftHandOperand);
            CtCodeSnippetExpression<Object> expressionReplacement = factory.createCodeSnippetExpression(replacement);
            loopingExpression.setLeftHandOperand(expressionReplacement);
        }

        if (VARIABLES_REPLACEMENT.containsKey(rightHandOperand)) {
            String replacement = VARIABLES_REPLACEMENT.get(rightHandOperand);
            CtCodeSnippetExpression<Object> expressionReplacement = factory.createCodeSnippetExpression(replacement);
            loopingExpression.setRightHandOperand(expressionReplacement);
        }

        CtBlock<?> whileBody = (CtBlock<?>) whileStatement.getBody();
        List<CtStatement> bodyStatements = whileBody.getStatements();
        CtStatementList bodyNewStatements = modifyStatements(factory, bodyStatements, initialStatement);
        CtBlockImpl<?> ctBlock = new CtBlockImpl<>();
        bodyNewStatements.forEach(ctStatement -> ctBlock.addStatement(ctStatement.clone()));    // Needs clone to avoid error by modify node parent.
        whileStatement.setBody(ctBlock);
        return whileStatement;
    }

    private static CtBlock<?> modifyIf(Factory factory, CtIfImpl initialStatement, CtIf ifElement) {
        CtBlockImpl<?> ctBlock = new CtBlockImpl<>();
        CtExpression<Boolean> initialStatementCondition = initialStatement.getCondition();
        CtExpression<Boolean> condition = ifElement.getCondition();
        String initialStatementConditionTarget = findConditionTarget(initialStatementCondition);
        String conditionTarget = findConditionTarget(condition);

        if (condition instanceof CtInvocation) {
            CtInvocation<Boolean> conditionInvocation = (CtInvocation<Boolean>) condition;
            List<CtExpression<?>> conditionInvocationArguments = conditionInvocation.getArguments();

            List<CtElement> invocations = new ArrayList<>();
            for (CtExpression<?> argument : conditionInvocationArguments) {
                if (argument instanceof CtInvocation &&
                        !((CtInvocation<?>) argument).getExecutable().getSimpleName().equals(initialStatementConditionTarget)) {

                    invocations.add(argument);
                }
            }

            CtExecutableReference<?> executable = conditionInvocation.getExecutable();
            if (!executable.getSimpleName().equals(initialStatementConditionTarget)) {
                invocations.add(executable);
            }
            CtExpression<?> conditionInvocationTarget = conditionInvocation.getTarget();
            if (!initialStatementConditionTarget.equals(conditionTarget) && conditionInvocationTarget instanceof CtInvocation) {
                invocations.add(conditionInvocationTarget);
            }

            invocations.forEach(invocation -> {
                if (invocation instanceof CtInvocation) {
                    String type = ((CtInvocation<?>) invocation).getType().toString();
                    counter++;
                    String newVariable = NAME_FOR_VARIABLE + counter;
                    CtCodeSnippetExpression<Object> expression = factory.createCodeSnippetExpression(newVariable);
                    VARIABLES_REPLACEMENT.put("", expression.toString());
                    CtCodeSnippetStatement codeSnippetStatement = factory.createCodeSnippetStatement(type + " " + newVariable + " = " + invocation);
                    ctBlock.addStatement(codeSnippetStatement);
                } else if (invocation instanceof CtExecutableReference) {
                    CtExecutableReference<?> executableReference = (CtExecutableReference<?>) invocation;
                    List<CtTypeReference<?>> executableParameters = executableReference.getParameters();
                    List<String> parametersVariable = new ArrayList<>(executableParameters.size());
                    String oldVariable = NAME_FOR_VARIABLE + counter;
                    String declaringType = executableReference.getDeclaringType().toString();
                    for (int idx = 0; idx < executableParameters.size(); idx++) {
                        counter++;
                        String newVariable = NAME_FOR_VARIABLE + counter;
                        CtCodeSnippetStatement variableInitiation = factory.createCodeSnippetStatement(declaringType + " " + newVariable + " = " + oldVariable);
                        ctBlock.addStatement(variableInitiation);
                        parametersVariable.add(newVariable);
                    }
                    String type = executableReference.getType().toString();
                    if (type.equalsIgnoreCase("boolean")) {
                        CtIf anIf = factory.createIf();
                        CtCodeSnippetExpression<Boolean> codeSnippetStatement = factory.createCodeSnippetExpression(oldVariable + "." + executableReference.getSimpleName() + "(" + String.join(" ,", parametersVariable) + ")");
                        anIf.setCondition(codeSnippetStatement);


                        CtBlock<?> thenStatement = ifElement.getThenStatement();
                        CtBlock<?> elseStatement = ifElement.getElseStatement();
                        CtStatementList newThenElement = modifyStatements(factory, thenStatement.clone().getStatements(), initialStatement);
                        CtBlock<?> newThenBlock = factory.createBlock();
                        newThenElement.forEach(newThenStatement -> newThenBlock.addStatement(newThenStatement.clone()));
                        anIf.setThenStatement(newThenBlock);
                        if (elseStatement != null) {
                            CtBlock<?> newElseBlock = factory.createBlock();
                            CtStatementList newElseElement = modifyStatements(factory, elseStatement.clone().getStatements(), initialStatement);
                            newElseElement.forEach(newElseStatement -> newElseBlock.addStatement(newElseStatement.clone()));
                            anIf.setElseStatement(newElseBlock);
                        }

                        ctBlock.addStatement(anIf);
                    }
                    logger.info("Token");
                }
            });
        }
        logger.info("Token");
        return ctBlock;
    }

    private static String findConditionTarget(CtExpression<Boolean> initialStatementCondition) {
        CtExpression<?> possibleTarget = initialStatementCondition;
        while (possibleTarget instanceof CtInvocation) {
            possibleTarget = ((CtInvocation<?>) possibleTarget).getTarget();
        }
        return possibleTarget.toString();
    }
}