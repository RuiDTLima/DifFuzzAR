import model.VulnerableMethodUses;
import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spoon.reflect.code.*;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.code.CtAssignmentImpl;
import spoon.support.reflect.code.CtBlockImpl;
import spoon.support.reflect.code.CtIfImpl;
import spoon.support.reflect.code.CtStatementListImpl;
import java.util.*;

// TODO beautify. Add comments and refactoring for optimization.
public class ControlFlowBasedVulnerabilityCorrection {
    private static final Logger logger = LoggerFactory.getLogger(ControlFlowBasedVulnerabilityCorrection.class);
    private static final String NAME_FOR_VARIABLE = "$";
    private static final TreeMap<String, String> VARIABLES_TO_ADD = new TreeMap<>();
    private static final BidiMap<String, String> VARIABLES_REPLACEMENT = new DualHashBidiMap<>();
    private static int counter = 0;

    public static void correctVulnerability(Factory factory, CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases){
        String[] secretArguments = findSecretArguments(modifiedMethod, vulnerableMethodUsesCases);
        for (String secretArgument : secretArguments) {
            logger.info("{} is a secret argument.", secretArgument);
        }

        CtBlock<?> methodBody = modifiedMethod.getBody();
        traverseMethodBody(factory, methodBody, secretArguments);

        List<CtLocalVariable<?>> variableList = methodBody.getElements(new TypeFilter<>(CtLocalVariable.class));
        counter = 0;
        // TODO is it worth to order the list just so that variables appear ordered?
        VARIABLES_TO_ADD.descendingMap().forEach((name, type) -> {
            String key = VARIABLES_REPLACEMENT.getKey(name);
            Optional<CtLocalVariable<?>> replacedVariable = variableList.stream()
                    .filter(variable -> variable.getSimpleName().equals(key))
                    .findFirst();
            CtCodeSnippetStatement newVariable;
            if (replacedVariable.isPresent()) {
                CtLocalVariable<?> localVariable = replacedVariable.get();
                CtExpression<?> assignment = localVariable.getDefaultExpression();
                if (assignment == null) {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name);
                } else {
                    newVariable = factory.createCodeSnippetStatement(type + " " + name + " = " + assignment);
                }
            } else {
                newVariable = factory.createCodeSnippetStatement(type + " " + name);
            }
            methodBody.addStatement(0, newVariable);
        });
        // TODO remove clear
        VARIABLES_TO_ADD.clear();
        VARIABLES_REPLACEMENT.clear();
    }

    private static String[] findSecretArguments(CtMethod<?> modifiedMethod, VulnerableMethodUses vulnerableMethodUsesCases) {
        ArrayList<Integer> secretArgumentsIndex = new ArrayList<>();
        String[] firstUseCaseArgumentsNames = vulnerableMethodUsesCases.getFirstUseCaseArgumentsNames();
        String[] secondUseCaseArgumentsNames = vulnerableMethodUsesCases.getSecondUseCaseArgumentsNames();

        for (int idx = 0; idx < firstUseCaseArgumentsNames.length; idx++) {
            if (!firstUseCaseArgumentsNames[idx].equals(secondUseCaseArgumentsNames[idx])) {
                logger.info("The argument in position {} is a secret.", idx);
                secretArgumentsIndex.add(idx);
            }
        }

        List<CtParameter<?>> parameters = modifiedMethod.getParameters();

        String[] secretArguments = new String[secretArgumentsIndex.size()];

        for (int idx = 0; idx < secretArgumentsIndex.size(); idx++) {
            secretArguments[idx] = parameters.get(secretArgumentsIndex.get(idx)).getSimpleName();
        }
        return secretArguments;
    }

    private static void traverseMethodBody(Factory factory, CtBlock<?> methodBody, String[] secretArguments) {
        for (CtStatement statement : methodBody) {
            if (statement instanceof CtIfImpl && usesSecret((CtIfImpl) statement, secretArguments)) {
                logger.info("Found the source of vulnerability.");
                handleVulnerability(factory, (CtIfImpl) statement);
            }
            if (statement instanceof CtLoop) {
                CtLoop ctLoop = (CtLoop) statement;
                traverseMethodBody(factory, ((CtBlock<?>)ctLoop.getBody()), secretArguments);
            }
        }
    }

    private static boolean usesSecret(CtIfImpl statement, String[] secretArguments) {
        for (String secretArgument : secretArguments) {
            if (Arrays.stream(statement.getCondition().toString().split("\\."))
                    .anyMatch(word -> word.matches(".*\\b" + secretArgument + "\\b.*"))) {
                return true;
            }
        }
        return false;
    }

    private static void handleVulnerability(Factory factory, CtIfImpl statement) {
        CtIf statementClone = statement.clone();
        CtBlock<?> thenStatement = statementClone.getThenStatement();
        CtBlock<?> elseStatement = statementClone.getElseStatement();
        if (elseStatement == null) {
            CtBlock<Object> block = factory.createBlock();
            elseStatement = block.insertBegin(modifyStatements(factory, thenStatement.getStatements()));
        } else {
            List<CtStatement> thenStatements = thenStatement.getStatements();
            List<CtStatement> elseStatements = elseStatement.clone().getStatements();   // TODO why clone?
            CtStatementList thenStatementsList = modifyStatements(factory, thenStatements);
            CtStatementList elseStatementsList = modifyStatements(factory, elseStatements);
            thenStatement.insertEnd(elseStatementsList);
            elseStatement.insertEnd(thenStatementsList);
            statement.setThenStatement(thenStatement);
        }
        statement.setElseStatement(elseStatement);
    }

    private static CtStatementList modifyStatements(Factory factory, List<CtStatement> statements) {
        CtStatementList statementList = new CtStatementListImpl<>();
        for (CtElement element : statements) {
            if (element instanceof CtAssignmentImpl) {
                CtAssignmentImpl<?, ?> assignmentImpl = (CtAssignmentImpl<?, ?>) element;
                logger.info("Found an assignment");
                CtExpression<?> assigned = assignmentImpl.getAssigned();
                CtExpression<?> assignment = assignmentImpl.getAssignment();
                String newAssigned;
                String newAssignment = assignment.toString();
                if (VARIABLES_REPLACEMENT.containsKey(assigned.toString())) {
                    newAssigned = VARIABLES_REPLACEMENT.get(assigned.toString());
                } else {
                    String type = assignmentImpl.getType().getSimpleName();
                    counter++;
                    newAssigned = NAME_FOR_VARIABLE + counter;
                    VARIABLES_REPLACEMENT.put(assigned.toString(), newAssigned);
                    VARIABLES_TO_ADD.put(newAssigned, type);
                }
                if (assignment instanceof CtArrayRead) {
                    CtArrayRead<?> arrayRead = (CtArrayRead<?>) assignment;
                    CtExpression<?> target = arrayRead.getTarget();
                    CtExpression<Integer> indexExpression = arrayRead.getIndexExpression();
                    CtArrayRead<?> newArrayRead = factory.createArrayRead();
                    if (VARIABLES_REPLACEMENT.containsKey(target.toString())) {
                        CtCodeSnippetExpression<?> newTarget = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(target.toString()));
                        newArrayRead.setTarget(newTarget);
                    } else {
                        newArrayRead.setTarget(target);
                    }
                    if (VARIABLES_REPLACEMENT.containsKey(indexExpression.toString())) {
                        CtCodeSnippetExpression<Integer> newIndex = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(indexExpression.toString()));
                        newArrayRead.setIndexExpression(newIndex);
                    }
                    newAssignment = newArrayRead.toString();
                } else if (assignment instanceof CtBinaryOperator){
                    CtBinaryOperator<?> binaryOperator = (CtBinaryOperator<?>) assignment;
                    CtExpression<?> leftHandOperand = binaryOperator.getLeftHandOperand();
                    CtExpression<?> rightHandOperand = binaryOperator.getRightHandOperand();
                    if (leftHandOperand instanceof CtVariableRead) {
                        String leftHandOperator = leftHandOperand.toString();
                        if (VARIABLES_REPLACEMENT.containsKey(leftHandOperator)) {
                            String newLeftHandOperatorVariable = VARIABLES_REPLACEMENT.get(leftHandOperator);
                            CtExpression<?> newLeftHandOperator = factory.createCodeSnippetExpression(newLeftHandOperatorVariable);
                            binaryOperator.setLeftHandOperand(newLeftHandOperator);
                        } else {
                            String type = leftHandOperand.getType().toString();
                            counter++;
                            CtExpression<?> newLeftHandOperator = factory.createCodeSnippetExpression(NAME_FOR_VARIABLE + counter);
                            binaryOperator.setLeftHandOperand(newLeftHandOperator);
                            VARIABLES_REPLACEMENT.put(leftHandOperator, newLeftHandOperator.toString());
                            VARIABLES_TO_ADD.put(newLeftHandOperator.toString(), type);
                        }
                    } else if (leftHandOperand instanceof CtArrayRead) {
                        CtArrayRead<?> arrayRead = (CtArrayRead<?>) leftHandOperand;
                        CtExpression<?> target = arrayRead.getTarget();
                        CtExpression<Integer> indexExpression = arrayRead.getIndexExpression();
                        CtArrayRead<?> newArrayRead = factory.createArrayRead();
                        if (VARIABLES_REPLACEMENT.containsKey(target.toString())) {
                            CtCodeSnippetExpression<?> newTarget = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(target.toString()));
                            newArrayRead.setTarget(newTarget);
                        } else {
                            newArrayRead.setTarget(target);
                        }
                        if (VARIABLES_REPLACEMENT.containsKey(indexExpression.toString())) {
                            CtCodeSnippetExpression<Integer> newIndex = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(indexExpression.toString()));
                            newArrayRead.setIndexExpression(newIndex);
                        }
                        binaryOperator.setLeftHandOperand(newArrayRead);
                    }
                    if (rightHandOperand instanceof CtVariableRead) {
                        String rightHandOperator = rightHandOperand.toString();
                        if (VARIABLES_REPLACEMENT.containsKey(rightHandOperator)) {
                            String newRightHandOperatorVariable = VARIABLES_REPLACEMENT.get(rightHandOperator);
                            CtExpression<?> newRightHandOperator = factory.createCodeSnippetExpression(newRightHandOperatorVariable);
                            binaryOperator.setRightHandOperand(newRightHandOperator);
                        } else {
                            String type = rightHandOperand.getType().toString();
                            counter++;
                            CtExpression<?> newRightHandOperator = factory.createCodeSnippetExpression(NAME_FOR_VARIABLE + counter);
                            binaryOperator.setRightHandOperand(newRightHandOperator);
                            VARIABLES_REPLACEMENT.put(rightHandOperator, newRightHandOperator.toString());
                            VARIABLES_TO_ADD.put(newRightHandOperator.toString(), type);
                        }
                    }
                    newAssignment = binaryOperator.toString();
                }

                CtStatement blockStatement = factory.createCodeSnippetStatement(newAssigned + " = " + newAssignment);
                statementList.addStatement(blockStatement);
            } else if (element instanceof CtLocalVariable) {
                counter++;
                String newVariable = NAME_FOR_VARIABLE + counter;
                CtLocalVariable<?> existingVariable = (CtLocalVariable<?>) element.clone();
                VARIABLES_REPLACEMENT.put(existingVariable.getSimpleName(), newVariable);
                CtNamedElement ctNamedElement = existingVariable.setSimpleName(newVariable);
                statementList.addStatement((CtStatement) ctNamedElement);
            } else if (element instanceof CtWhile) {
                CtWhile whileStatement = ((CtWhile) element.clone());
                CtBinaryOperator<Boolean> loopingExpression = (CtBinaryOperator<Boolean>) whileStatement.getLoopingExpression();
                String leftHandOperand = loopingExpression.getLeftHandOperand().toString();
                String rightHandOperand = loopingExpression.getRightHandOperand().toString();

                if (VARIABLES_REPLACEMENT.containsKey(leftHandOperand)) {
                    String replacement = VARIABLES_REPLACEMENT.get(leftHandOperand);
                    CtCodeSnippetExpression<Object> expressionReplacement = factory.createCodeSnippetExpression(replacement);
                    loopingExpression.setLeftHandOperand(expressionReplacement);
                }

                if (VARIABLES_REPLACEMENT.containsKey(rightHandOperand)) {
                    String replacement = VARIABLES_REPLACEMENT.get(rightHandOperand);
                    CtCodeSnippetExpression<Object> expressionReplacement = factory.createCodeSnippetExpression(replacement);
                    loopingExpression.setRightHandOperand(expressionReplacement);
                }

                List<CtStatement> bodyStatements = ((CtBlock<?>) whileStatement.getBody()).getStatements();
                CtStatementList bodyNewStatements = modifyStatements(factory, bodyStatements);
                CtBlockImpl<?> ctBlock = new CtBlockImpl<>();
                bodyNewStatements.forEach(ctStatement -> ctBlock.addStatement(ctStatement.clone()));    // Needs clone to avoid error by modify node parent.
                whileStatement.setBody(ctBlock);
                statementList.addStatement(whileStatement);
            } else if (element instanceof CtUnaryOperator) {
                CtUnaryOperator<?> unaryOperator = (CtUnaryOperator<?>) element;
                String operand = unaryOperator.getOperand().toString();
                if (VARIABLES_REPLACEMENT.containsKey(operand)) {
                    CtExpression variableExpression = factory.createCodeSnippetExpression(VARIABLES_REPLACEMENT.get(operand));
                    CtUnaryOperator<?> ctUnaryOperator = unaryOperator.setOperand(variableExpression);
                    statementList.addStatement(ctUnaryOperator);
                }
            }
        }
        return statementList;
    }
}